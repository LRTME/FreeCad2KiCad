import FreeCAD as App
import FreeCADGui as Gui

import json
import logging
import sys
import socket
import threading
import os

from PySide import QtGui, QtCore

from board_drawer import PcbDrawer
from constants import SCALE
from freecad_functions import *
from part_updater import PartUpdater

try:
    # Get config data
    from config import MODELS_PATH, HOST, STARTING_PORT, HEADER, FORMAT
    config_imported = True
except ModuleNotFoundError:
    config_imported = False
    error_msg = QtGui.QMessageBox.critical(None,
                                           "Error!",
                                           "No valid config file in directory!",
                                           QtGui.QMessageBox.Abort)

# Set up logger
logger = logging.getLogger(__name__)
# Get plugin directory and add /Logs folder
dir_path = os.path.dirname(os.path.realpath(__file__))
if not os.path.exists(dir_path + "/Logs"):
    os.makedirs(dir_path + "/Logs")
handler = logging.FileHandler(dir_path + "/Logs/freecad_host.log")
formatter = logging.Formatter("%(asctime)s - %(message)s", "%d/%m/%Y %H:%M:%S")
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(logging.DEBUG)


class Server(QtCore.QObject):

    finished = QtCore.Signal()
    connected = QtCore.Signal(type(socket.socket))

    def __init__(self):
        super().__init__()
        self.port = STARTING_PORT

    @QtCore.Slot()
    def workerSlot(self):
        print("[SERVER] Closing connection manually")
        logger.info("[SERVER] Closing connection manually")
        self.socket.close()

    def run(self):
        """Worker thread for starting socket and listening for client"""

        print("[SERVER] Server starting")
        logger.info("[SERVER] Server starting")
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # Loop through available sockets
        socket_searching = True
        while socket_searching:
            if self.port > (self.port + 20):
                socket_searching = False
                self.port = 5050
                print(f"[SERVER] Failed to start server, port reset to: {self.port}")
                logger.info(f"[SERVER] Failed to start server, port reset to: {self.port}")
                self.finished.emit()

            try:
                self.socket.bind((HOST, self.port))
                socket_searching = False
                # Wait for connection
                self.socket.listen()
                print(f"[SERVER] Server is listening on {HOST}, port {self.port}")
                logger.info(f"[SERVER] Server is listening on {HOST}, port {self.port}")

                while True:
                    # Accept new connection
                    self.conn, self.addr = self.socket.accept()
                    print(f"[SERVER] Client connected: {self.addr}")
                    logger.info(f"[SERVER] Client connected: {self.addr}")
                    self.socket.close()
                    print("[SERVER] Server socket closed")
                    logger.info("[SERVER] Server socket closed")
                    # Emit Qt Signal
                    self.connected.emit(self.conn)
                    self.finished.emit()
                    break

            except OSError as e:
                # BUG: error message when manually closing socket.
                # FIX: Catch error number 10038 (on windows: Operation was attempted on
                #                                            something that is not a socket)
                if e.errno == 10038:
                    pass
                # Only one usage of each socket address is permitted
                elif e.errno == 10048:
                    self.port = self.port + 1
                else:
                    print(e)
                    self.finished.emit()


class ConnectionHandler(QtCore.QObject):

    finished = QtCore.Signal()
    received_pcb = QtCore.Signal(dict)
    received_diff = QtCore.Signal(dict)

    def __init__(self, connection_socket):
        super().__init__()
        self.socket = connection_socket

    def run(self):
        """Worker thread for receiving messages from client"""

        logger.debug(f"[CONNECTION] Connection thread running")

        self.connected = True
        while self.connected:
            # Receive first message
            first_msg = self.socket.recv(HEADER).decode(FORMAT)
            # Check if anything was actually sent, skip if not
            if not first_msg:
                continue
            # Split first message -> first half is type (pcb, diff, disconnect), second is length
            msg_type = first_msg.split('_')[0]
            msg_length = first_msg.split('_')[1]
            # Receive second message
            msg_length = int(msg_length)
            data_raw = self.socket.recv(msg_length).decode(FORMAT)
            data = json.loads(data_raw)

            # Check for disconnect message
            if msg_type == "!DIS":
                self.connected = False
                logger.info(f"[CONNECTION] Disconnect message received: {data}")

            elif msg_type == "PCB":
                if not isinstance(data, dict):
                    continue
                logger.info(f"[CONNECTION] PCB Dictionary received: {data}")
                self.received_pcb.emit(data)


            elif msg_type == "DIF":
                if not isinstance(data, dict):
                    continue

                logger.info(f"[CONNECTION] Diff Dictionary received: {data}")
                self.received_diff.emit(data)

        self.socket.close()
        self.finished.emit()
        logger.info("[CONNECTION] Client disconnected, connection closed")
        print("[CONNECTION] Client disconnected, connection closed")


class FreeCadHost(QtGui.QDockWidget, QtCore.QObject):

    # QT signal for stopping server in worker thread
    stop_server_signal = QtCore.Signal()

    def __init__(self):
        super().__init__()
        self.doc = App.activeDocument()
        self.doc_gui = Gui.ActiveDocument
        self.pcb = None
        self.diff = None

        self.setupUi()

    def setupUi(self):
        self.setObjectName("FreeCAD Host")
        self.resize(QtCore.QSize(300, 100).expandedTo(self.minimumSizeHint()))  # sets size of the widget

        # Text
        self.text_connection = QtGui.QLabel("", self)
        self.text_connection.move(30, 25)
        self.text_connection.resize(180, 25)
        self.text_connection.hide()

        self.text_controls = QtGui.QLabel("Object controls:", self)
        self.text_controls.move(10, 90)

        # Buttons
        self.button_start_server = QtGui.QPushButton("Accept new connection", self)
        self.button_start_server.clicked.connect(self.onButtonStartServer)
        self.button_start_server.move(25, 25)
        self.button_start_server.resize(180, 25)

        self.button_stop_server = QtGui.QPushButton("Stop listening", self)
        self.button_stop_server.clicked.connect(self.onButtonStopServer)
        self.button_stop_server.hide()
        self.button_stop_server.move(25, 25)
        self.button_stop_server.resize(180, 25)
        self.button_stop_server.setEnabled(False)

        self.button_draw_pcb = QtGui.QPushButton("Draw pcb", self)
        self.button_draw_pcb.clicked.connect(self.onButtonDraw)
        self.button_draw_pcb.move(10, 120)
        self.button_draw_pcb.setEnabled(False)

        self.button_apply_diff = QtGui.QPushButton("Apply diff", self)
        self.button_apply_diff.clicked.connect(self.onButtonApplyDiff)
        self.button_apply_diff.move(120, 120)
        self.button_apply_diff.setEnabled(False)

        self.button_scan_board = QtGui.QPushButton("Scan PCB", self)
        self.button_scan_board.clicked.connect(self.onButtonScanBoard)
        self.button_scan_board.move(10, 180)
        self.button_scan_board.setEnabled(False)

    # ---------------------------------------------------------------------------

    def connectedButtons(self):
        self.text_connection.setText(f"Connected")
        self.text_connection.show()

    def disconnectedButtons(self):
        self.text_connection.hide()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

        self.button_apply_diff.setEnabled(False)
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()

    def serverClosedButtons(self):
        # Disable stop and enable start when server is stopped
        self.button_start_server.setEnabled(False)
        self.button_start_server.hide()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

    def serverStartButtons(self):
        # Enable stop button and disable start when starting server
        self.button_stop_server.setEnabled(True)
        self.button_stop_server.show()
        self.button_start_server.setEnabled(False)
        self.button_start_server.hide()

    # --------------------------------- Button Methods --------------------------------- #
    def onButtonStartServer(self):
        self.startServerThread()

    def onButtonStopServer(self):
        # logger.debug("Emmiting manual stop signal")
        # print("Emmiting manual stop signal")
        # self.stop_server_signal.emit()

        self.button_start_server.setEnabled(True)
        self.button_start_server.show()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

    def onButtonDraw(self):
        drawPcb(doc=self.doc,
                doc_gui=Gui.ActiveDocument,
                pcb=self.pcb,
                MODELS_PATH=MODELS_PATH)

    def onButtonApplyDiff(self):
        if self.pcb and self.diff:
            updatePartFromDiff(self.doc, self.pcb, self.diff)

            self.doc.recompute()
            self.diff = None

    def onButtonScanBoard(self):
        scanFootprints(doc=self.doc,
                       pcb=self.pcb)
        self.doc.recompute()

    # --------------------------------- QThreads --------------------------------- #
    def startServerThread(self):
        self.server_thread = QtCore.QThread()
        self.server = Server()
        self.server.moveToThread(self.server_thread)

        # Connect signals and slots
        self.server_thread.started.connect(self.server.run)
        self.server.finished.connect(self.server_thread.quit)
        self.server.finished.connect(self.server.deleteLater)
        self.server_thread.finished.connect(self.server_thread.deleteLater)
        # "connected" signal passes socket.socket class to startClientThread method for instantiating Connection
        self.server.connected.connect(self.startClientThread)
        # Connect a signal to worker slot for communicating back to worker thread (stop server)
        self.stop_server_signal.connect(self.server.workerSlot)

        # Start the thread
        self.server_thread.start()

        # Final resets
        # Enable stop button and disable start when starting server
        self.serverStartButtons()
        # Disable stop end enable start when server is stopped
        self.server_thread.finished.connect(
            lambda: self.serverClosedButtons()
        )


    def startClientThread(self, connection_socket):
        self.client_thread = QtCore.QThread()
        # Instatiate Connection class with client connection socket
        self.connection = ConnectionHandler(connection_socket)
        self.connection.moveToThread(self.client_thread)

        # Connecting signals
        self.client_thread.started.connect(self.connection.run)
        self.connection.finished.connect(self.client_thread.quit)
        self.connection.finished.connect(self.connection.deleteLater)
        self.client_thread.finished.connect(self.client_thread.deleteLater)
        # Set and draw PCB signals
        self.connection.received_pcb.connect(self.setPcb)
        self.connection.received_pcb.connect(self.startPcbDrawerThread)
        # Apply Diff signal
        self.connection.received_diff.connect(self.startPartUpdaterThread)

        # Start handle client thread
        self.client_thread.start()

        # Reset
        self.connectedButtons()
        self.connection.finished.connect(
            lambda: self.disconnectedButtons()
        )

    def startPcbDrawerThread(self, pcb):
        self.pcb_drawer_thread = QtCore.QThread()
        self.pcb_drawer = PcbDrawer(doc=self.doc,
                                    doc_gui=self.doc_gui,
                                    pcb=pcb,
                                    models_path=MODELS_PATH)
        self.pcb_drawer.moveToThread(self.pcb_drawer_thread)
        # Signals
        self.pcb_drawer_thread.started.connect(self.pcb_drawer.run)
        self.pcb_drawer.finished.connect(self.pcb_drawer_thread.quit)
        self.pcb_drawer.finished.connect(self.pcb_drawer.deleteLater)
        self.pcb_drawer_thread.finished.connect(self.pcb_drawer_thread.deleteLater)
        self.pcb_drawer.progress.connect(self.logDrawerProgress)
        # Start thread
        self.pcb_drawer_thread.start()

    def logDrawerProgress(self, status):
        logger.debug(f"[DRAWER] {status}")

    # def guiViewFit(self):
    #     Gui.SendMsgToActiveView("ViewFit")

    def startPartUpdaterThread(self, diff):
        self.update_thread = QtCore.QThread()
        self.update_obj = PartUpdater(doc=App.activeDocument(),
                                      pcb=self.pcb,
                                      diff=diff)
        self.update_obj.moveToThread(self.update_thread)
        # Connecting signals
        self.update_thread.started.connect(self.update_obj.run)
        self.update_obj.finished.connect(self.update_thread.quit)
        self.update_obj.finished.connect(self.update_obj.deleteLater)
        self.update_thread.finished.connect(self.update_thread.deleteLater)
        self.update_obj.progress.connect(self.logUpdaterProgress)
        # Connect finished signal to setter function for setting new pcb dict
        self.update_obj.finished.connect(self.setPcb)
        # Start apply diff thread
        self.update_thread.start()

    def logUpdaterProgress(self, status):
        logger.debug(f"[UPDATER] {status}")

    # ---------------------------------------------------------------------------------

    def setPcb(self, data):
        self.pcb = data
        logger.debug(f"[HOST] PCB Dictionary set: {self.pcb}")
        self.button_draw_pcb.setEnabled(True)
        self.button_scan_board.setEnabled(True)


    def closeSocket(self):
        print("Closing connection manually")
        self.socket.close()

        self.button_start_server.setEnabled(True)
        self.button_start_server.show()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()


    def sendMessage(self, msg):
        # Calculate length of first message
        msg_length = len(msg)
        send_length = str(msg_length).encode(self.FORMAT)
        # Pad first message
        send_length += b' ' * (self.HEADER - len(send_length))
        # Send length end object
        self.conn.send(send_length)
        self.conn.send(msg.encode(self.FORMAT))


if config_imported:
    # Instantiate host plugin
    host_plugin = FreeCadHost()
    # Add the widget to the main window right area
    Gui.getMainWindow().addDockWidget(QtCore.Qt.RightDockWidgetArea, host_plugin)