import FreeCAD as App
import FreeCADGui as Gui

import configparser
import hashlib
import json
import logging
import logging.config
import os
import sys

from PySide import QtGui, QtCore

from API_scripts.part_scanner import FcPcbScanner
from API_scripts.part_drawer import FcPcbDrawer
from API_scripts.part_updater import FcPartUpdater
from Config.config_loader import ConfigLoader
from Socket.server import Server, ReceiveMessage


# Get the path to log file because configparsed doesn't search for the file in same directory where module is saved
# in file system. (it searches in directory where script is executed)
directory_path = os.path.dirname(os.path.realpath(__file__))
# Backslash is replaced with forwardslash, otherwise the file paths don't work
logging_config_file = os.path.join(directory_path, "Config", "logging.ini").replace("\\", "/")
# Define directory path for /Logs
log_files_directory = os.path.join(directory_path, "Logs").replace("\\", "/")
# Configure logging module with .ini file, pass /Logs directory as argument (part of formatted string in .ini)
logging.config.fileConfig(logging_config_file, defaults={"log_directory": log_files_directory})

# Initialize logger and log basic system info:
logger = logging.getLogger()
logger.info("Plugin executed on: " + repr(sys.platform))
logger.info("Plugin executed with python version: " + repr(sys.version))
logger.info("FreeCAD build version: " + str(App.Version()))

# Button placement magic values
FIRST_COLUMN_X = 10
SECOND_COLUMN_X = 120
INITIAL_Y = 120
OFFSET_Y = 60


class FreeCadHost(QtGui.QDockWidget):

    # # QT signal for stopping server in worker thread
    # stop_server_signal = QtCore.Signal()

    def __init__(self):
        super().__init__()

        # Get FreeCAD document and GUI objects
        self.doc = App.activeDocument()
        self.doc_gui = Gui.ActiveDocument

        # Initialize dictionary variables
        self.pcb = {}
        self.diff = {}

        # Get config.ini file path
        config_file = os.path.join(directory_path, "Config", "config.ini").replace("\\", "/")
        # Load config data
        self.config = ConfigLoader(config_file)
        logger.info(f"Loaded configuration: {self.config.getConfig()}")

        # Set up the User Interface
        self.setupUi()

    def setupUi(self):
        self.setObjectName("FreeCAD Host")
        self.resize(QtCore.QSize(300, 100).expandedTo(self.minimumSizeHint()))  # sets size of the widget

        # Text
        self.text_connection = QtGui.QLabel("", self)
        self.text_connection.move(30, 25)
        self.text_connection.resize(180, 25)
        self.text_connection.hide()

        self.text_controls = QtGui.QLabel("Object controls:", self)
        self.text_controls.move(10, 90)

        # Buttons
        self.button_start_server = QtGui.QPushButton("Accept new connection", self)
        self.button_start_server.clicked.connect(self.onButtonStartServer)
        self.button_start_server.move(25, 25)
        self.button_start_server.resize(180, 25)

        self.button_stop_server = QtGui.QPushButton("Stop listening", self)
        self.button_stop_server.clicked.connect(self.onButtonStopServer)
        self.button_stop_server.hide()
        self.button_stop_server.move(25, 25)
        self.button_stop_server.resize(180, 25)
        self.button_stop_server.setEnabled(False)

        self.button_request_pcb = QtGui.QPushButton("Accept PCB", self)
        self.button_request_pcb.clicked.connect(self.onButtonRequestPcb)
        self.button_request_pcb.move(FIRST_COLUMN_X, INITIAL_Y)
        self.button_request_pcb.setEnabled(False)

        self.button_attach_pcb = QtGui.QPushButton("Attach PCB", self)
        self.button_attach_pcb.clicked.connect(self.onButtonAttachPcb)
        self.button_attach_pcb.move(SECOND_COLUMN_X, INITIAL_Y)
        self.button_attach_pcb.setEnabled(False)

        self.button_sync = QtGui.QPushButton("Sync", self)
        self.button_sync.clicked.connect(self.onButtonSync)
        self.button_sync.move(FIRST_COLUMN_X, INITIAL_Y + OFFSET_Y)
        self.button_sync.setEnabled(False)

        self.button_refresh = QtGui.QPushButton("Refresh", self)
        self.button_refresh.clicked.connect(self.onButtonRefresh)
        self.button_refresh.move(SECOND_COLUMN_X, INITIAL_Y + OFFSET_Y)
        self.button_refresh.setEnabled(False)

    # --------------------------------- Button Methods --------------------------------- #
    def onButtonStartServer(self):
        self.startServer()

    def onButtonStopServer(self):
        # Call stop method (in another thread) to queue abort
        self.server.stop()
        # Set appropriate button visibility
        self.serverClosedButtons()

    def onButtonRequestPcb(self):
        self.requestPcb()

    def onButtonAttachPcb(self):
        self.attachPcb()

    def onButtonSync(self):
        self.requestDiff()

    def onButtonRefresh(self):
        # TODO
        # refresh document?
        pass

    # --------------------------------- Hude/Show Buttons --------------------------------- #

    def connectedButtons(self):
        # Change large button text and visibility
        self.text_connection.setText(f"Connected")
        self.text_connection.show()
        self.button_stop_server.hide()
        self.button_start_server.hide()
        # Enable buttons for requesting pcb or attaching pcb
        self.button_request_pcb.setEnabled(True)
        self.button_attach_pcb.setEnabled(True)

    def disconnectedButtons(self):
        # Change large button text and visibility
        self.text_connection.hide()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

        # self.button_apply_diff.setEnabled(False)
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()

    def serverClosedButtons(self):
        # Disable stop and enable start when server is stopped
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

    def serverStartButtons(self):
        # Enable stop button and disable start when starting server
        self.button_start_server.setEnabled(False)
        self.button_start_server.hide()
        self.button_stop_server.setEnabled(True)
        self.button_stop_server.show()

    # --------------------------------- QThreads --------------------------------- #
    def startServer(self):
        """ 1. step: Start server in a new thread. Thread is stopped and deleted when connection to client occurs. """
        self.server_thread = QtCore.QThread()
        self.server = Server(self.config)
        self.server.moveToThread(self.server_thread)

        # Connect signals and slots
        self.server_thread.started.connect(self.server.run)
        self.server.finished.connect(self.server_thread.quit)
        self.server.finished.connect(self.server.deleteLater)
        self.server_thread.finished.connect(self.server_thread.deleteLater)
        # Connect finished signal to startConnection method - this passes socket.socket object to ConnectionHandler
        self.server.finished.connect(self.onServerFinished)

        # Start the thread
        self.server_thread.start()
        # Enable stop button and disable start when starting server
        self.serverStartButtons()

    def onServerFinished(self, server_response):
        """ 2. step: Attach socket objects to self. """
        # Get data from dictionary type
        status = server_response.get("status")

        # Perform check if connection is real or fake (quasy-abort) see Server class doctring
        if status == "abort":
            logger.debug("Server aborted, ignoring connection socket")
            # Show correct button configuration - server was aborted, enable button for starting server again
            self.serverClosedButtons()

        elif status == "exception":
            logger.error(f"Exception when starting server")

        elif status == "client_connected":
            # Get data from dictionary type
            connection_socket = server_response.get("connection_socket")
            # Attach connection handle (socket) to class, so that a message can be sent manually by button (sendMessage)
            self.socket = connection_socket
            # Change button visibility
            self.connectedButtons()
            logger.debug("Client connected.")

    def attachPcb(self):
        # Disable button for requesting pcb from KiCAD (since pcb data model is going to be attached)
        self.button_request_pcb.setEnabled(False)
        # TODO exiting FC part must be selected.
        #  Read .JSON property of this part (which is data model of the part)
        #  attach is as self.pcb

    def requestPcb(self):
        """ 3. step: send a request message over socket, listen for reply in a new thread. """

        # Send message to request pcb from KiCAD
        self.sendMessage("", msg_type="REQ_PCB")

        # Run ConnectioHandler in a new thread to listen for reply
        self.listen_thread = QtCore.QThread()
        # Instatiate Connection class with client connection Socket
        self.connection = ConnectionHandler(self.socket, self.config)
        self.connection.moveToThread(self.listen_thread)
        # Connecting signals
        self.listen_thread.started.connect(self.connection.run)
        self.connection.finished.connect(self.listen_thread.quit)
        self.connection.finished.connect(self.connection.deleteLater)
        self.connection.finished.connect(self.onConnectionHandlerFinished)
        self.listen_thread.finished.connect(self.listen_thread.deleteLater)
        self.connection.received_pcb.connect(self.onReceivedPcb)
        # Start thread
        self.listen_thread.start()

    def onReceivedPcb(self):
        """ 4. step: call function to draw part object, enable Sync button when finished. """
        self.startPcbDrawer()

    def onPcbDrawerFinished(self):
        """ Called when drawer is finished, enables Sync button. """
        # Enable Sync button.
        self.button_sync.setEnabled(True)

    def requestDiff(self):
        """ 5. step """
        logger.info("Sending request message.")
        # TODO
        # send request message
        # run ReceiveMessage in a new thread

    def onReceivedDiff(self):
        """ 6. step """
        # TODO
        # link this function on Diff signal of ConnectionHandler
        # do collision detection (diff merge)
        # send merged diff message
        # run ConnectionHandler to listen for reply
        pass

    def onReceivedDiffReply(self):
        """ 7. step """
        # TODO
        # link this function on Diff return signal (new diff contains KIID of new drawing)
        # call part updater on new diff
        # calculate hash of data model
        # send message to confirm sync
        pass

    # def startConnection(self, server_response: dict):
    #     # Get data from dictionary type
    #     status = server_response.get("status")
    #
    #     # Perform check if connection is real or fake (quasy-abort) see Server class doctring
    #     if status == "abort":
    #         logger.debug("Server aborted, ignoring connection socket")
    #         # Show correct button configuration - server was aborted, enable button for starting server again
    #         self.serverClosedButtons()
    #
    #     elif status == "exception":
    #         logger.error(f"Exception when starting server")
    #
    #     elif status == "client_connected":
    #         # Change button visibility
    #         self.connectedButtons()
    #         logger.debug("Client connected, launching connection handler")
    #
    #         # Get data from dictionary type
    #         connection_socket = server_response.get("connection_socket")
    #         # Attach connection handle (socket) to class, so that a message can be sent manually by button (sendMessage)
    #         self.socket = connection_socket
    #
    #         # Start Handler in new thread
    #         self.client_thread = QtCore.QThread()
    #         # Instatiate Connection class with client connection Socket
    #         self.connection = ConnectionHandler(connection_socket, self.config)
    #         self.connection.moveToThread(self.client_thread)
    #
    #         # Connecting signals
    #         self.client_thread.started.connect(self.connection.run)
    #         self.connection.finished.connect(self.client_thread.quit)
    #         self.connection.finished.connect(self.connection.deleteLater)
    #         self.connection.finished.connect(self.onConnectionHandlerFinished)
    #         self.client_thread.finished.connect(self.client_thread.deleteLater)
    #         # Set and draw PCB signals
    #         self.connection.received_pcb.connect(self.setPcb)
    #         self.connection.received_pcb.connect(self.startPcbDrawer)
    #         # Apply Diff signal
    #         self.connection.received_diff.connect(self.startPartUpdater)
    #         # Hash received signal
    #         self.connection.received_hash.connect(self.onReceivedHash)
    #
    #         # Start handle client thread
    #         self.client_thread.start()
    #
    #         # # Reset buttons
    #         # self.connectedButtons()
    #         # self.connection.finished.connect(
    #         #     lambda: self.disconnectedButtons()
    #         # )
    #
    # def onConnectionHandlerFinished(self):
    #     # Changed button visibility
    #     self.disconnectedButtons()


    def onReceivedHash(self, received_pcb_hash: str):
        """
        Compare received hash to own hash, if same clear local diff
        :param received_pcb_hash: str
        :return:
        """
        logger.debug(f"Received hash: {received_pcb_hash}")
        own_pcb_hash = hashlib.md5(str(self.pcb).encode("utf-8")).hexdigest()
        logger.debug(f"Own hash: {own_pcb_hash}")

        # Dump data model for debugging
        FreeCadHost.dumpToJsonFile(self.pcb, "/Logs/data_indent.json")

        if received_pcb_hash == own_pcb_hash:
            logger.info(f"Hash match, diff synced")
            logger.info(f"Clearing local diff: {self.diff}")
            self.diff = {}
        else:
            logger.error(f"Hash mismatch, sync lost!")


    def startPcbDrawer(self):
        self.pcb_drawer_thread = QtCore.QThread()
        self.pcb_drawer = FcPcbDrawer(doc=self.doc,
                                      doc_gui=self.doc_gui,
                                      pcb=self.pcb,
                                      models_path=self.config.models_path)
        self.pcb_drawer.moveToThread(self.pcb_drawer_thread)
        # Connect signals
        self.pcb_drawer_thread.started.connect(self.pcb_drawer.run)
        self.pcb_drawer.finished.connect(self.sendHashOfDataModel)
        self.pcb_drawer.finished.connect(self.pcb_drawer_thread.quit)
        self.pcb_drawer.finished.connect(self.pcb_drawer.deleteLater)
        self.pcb_drawer_thread.finished.connect(self.pcb_drawer_thread.deleteLater)
        self.pcb_drawer.finished.connect(self.onPcbDrawerFinished)
        # Log signal
        self.pcb_drawer.progress.connect(self.logDrawerProgress)
        # Start thread
        self.pcb_drawer_thread.start()

    @staticmethod
    def logDrawerProgress(status: str):
        # This function exist because when logging in pcb_drawer module FC crashed. Log is passed by signal and logged
        # here:
        logger.debug(f"[DRAWER] {status}")

    def startPartUpdater(self, diff: dict):
        self.update_thread = QtCore.QThread()
        self.update_obj = FcPartUpdater(doc=self.doc,
                                        pcb=self.pcb,
                                        diff=diff)
        self.update_obj.moveToThread(self.update_thread)
        # Connecting signals
        # Connect start signal to run() method
        self.update_thread.started.connect(self.update_obj.run)
        # Finished signal
        self.update_obj.finished.connect(self.finishedPartUpdater)
        self.update_obj.finished.connect(self.update_thread.quit)
        self.update_obj.finished.connect(self.update_obj.deleteLater)
        self.update_thread.finished.connect(self.update_thread.deleteLater)
        # Start apply diff thread
        self.update_thread.start()

    def finishedPartUpdater(self):
        # First send hash of updated pcb dictionary, then clear local diff -> we assume all changes were applied in
        # Updater script
        self.sendHashOfDataModel()
        logger.info(f"Clearing local Diff: {self.diff}")
        self.diff = {}

    def sendHashOfDataModel(self):
        """ Call this function after updating part so KiCAD can confirm change """
        # Convert pcb dictionary to encoded string, hash string, convert hash object to string
        pcb_hash = hashlib.md5(str(self.pcb).encode("utf-8")).hexdigest()

        logger.info("Sending hash")
        # Send this hash as message to KC
        self.sendMessage(json.dumps(pcb_hash), msg_type="HASH")

    def startPartScanner(self):
        self.scanner_thread = QtCore.QThread()
        self.scanner_obj = FcPcbScanner(doc=self.doc,
                                        pcb=self.pcb,
                                        diff=self.diff)
        self.scanner_obj.moveToThread(self.scanner_thread)

        # Connecting signals
        # Connect start signal to run() method
        self.scanner_thread.started.connect(self.scanner_obj.run)
        # Finished signal
        self.scanner_obj.finished.connect(self.finishedPcbScanner)
        self.scanner_obj.finished.connect(self.scanner_thread.quit)
        self.scanner_obj.finished.connect(self.scanner_obj.deleteLater)
        self.scanner_thread.finished.connect(self.scanner_thread.deleteLater)

        # Start thread
        logger.info(f"Calling scanner")
        self.scanner_thread.start()

    def finishedPcbScanner(self, diff: dict):
        logger.debug(f"finishedPcbScanner, returns: {diff}")
        self.diff = diff
        logger.info(f"Diff: {self.diff}")
        FreeCadHost.dumpToJsonFile(self.diff, "/Logs/diff.json")
        FreeCadHost.dumpToJsonFile(self.pcb, "/Logs/data_indent.json")
        self.refreshDocument()

    # ------------------------------------| Utils |---------------------------------------------

    def sendMessage(self, msg: str, msg_type: str = "!DIS"):
        """
        Message can be type (by convention) of !DIS, REQ_PCB, REQ_DIF, DIF
        :param msg: json encoded string
        :param msg_type: str
        :return:
        """
        logger.debug(f"Sending message {msg_type}_{msg}")
        # Calculate length of first message
        msg_length = len(msg)
        send_length = str(msg_length)
        # First message is type and length of second message
        first_message = f"{msg_type}_{send_length}".encode(self.config.format)
        # Pad first message
        first_message += b' ' * (self.config.header - len(first_message))
        # Send length and object
        self.socket.send(first_message)
        self.socket.send(msg.encode(self.config.format))

    def refreshDocument(self):
        logger.info(f"Recomputing document")
        self.doc.recompute()

    @staticmethod
    def dumpToJsonFile(data, filename: str):
        with open(directory_path + filename, "w") as f:
            json.dump(data, f, indent=4)


# Instantiate host plugin
host_plugin = FreeCadHost()
# Add the widget to the main window right area
Gui.getMainWindow().addDockWidget(QtCore.Qt.RightDockWidgetArea, host_plugin)