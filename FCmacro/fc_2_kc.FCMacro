import FreeCAD as App
import FreeCADGui as Gui

import configparser
import json
import logging
import logging.config
import os
import sys

from PySide import QtGui, QtCore

from API_scripts.pcb_scanner import FcPcbScanner
from API_scripts.pcb_drawer import FcPcbDrawer
from API_scripts.part_updater import FcPartUpdater
from Config.config_loader import ConfigLoader
from Socket.server import Server, ConnectionHandler


# Get the path to log file because configparsed doesn't search for the file in same directory where module is saved
# in file system. (it searches in directory where script is executed)
directory_path = os.path.dirname(os.path.realpath(__file__))
# Backslash is replaced with forwardslash, otherwise the file paths don't work
config_file = os.path.join(directory_path, "Config", "logging.ini").replace("\\", "/")
# Define directory path for /Logs
log_files_directory = os.path.join(directory_path, "Logs").replace("\\", "/")
# Configure logging module with .ini file, pass /Logs directory as argument (part of formatted string in .ini)
logging.config.fileConfig(config_file, defaults={"log_directory": log_files_directory})

# Initialize logger and log basic system info:
logger = logging.getLogger()
logger.info("Plugin executed on: " + repr(sys.platform))
logger.info("Plugin executed with python version: " + repr(sys.version))
logger.info("FreeCAD build version: " + str(App.Version()))


class FreeCadHost(QtGui.QDockWidget, QtCore.QObject):

    # QT signal for stopping server in worker thread
    stop_server_signal = QtCore.Signal()

    def __init__(self):
        super().__init__()

        # Get FreeCAD document and GUI objects
        self.doc = App.activeDocument()
        self.doc_gui = Gui.ActiveDocument

        # Initialize dictionary variables
        self.pcb = None
        self.diff = None

        # Load config data
        self.config = ConfigLoader()

        # Set up the User Interface
        self.setupUi()

    def setupUi(self):
        self.setObjectName("FreeCAD Host")
        self.resize(QtCore.QSize(300, 100).expandedTo(self.minimumSizeHint()))  # sets size of the widget

        # Text
        self.text_connection = QtGui.QLabel("", self)
        self.text_connection.move(30, 25)
        self.text_connection.resize(180, 25)
        self.text_connection.hide()

        self.text_controls = QtGui.QLabel("Object controls:", self)
        self.text_controls.move(10, 90)

        # Buttons
        self.button_start_server = QtGui.QPushButton("Accept new connection", self)
        self.button_start_server.clicked.connect(self.onButtonStartServer)
        self.button_start_server.move(25, 25)
        self.button_start_server.resize(180, 25)

        self.button_stop_server = QtGui.QPushButton("Stop listening", self)
        self.button_stop_server.clicked.connect(self.onButtonStopServer)
        self.button_stop_server.hide()
        self.button_stop_server.move(25, 25)
        self.button_stop_server.resize(180, 25)
        self.button_stop_server.setEnabled(False)

        self.button_draw_pcb = QtGui.QPushButton("Draw pcb", self)
        self.button_draw_pcb.clicked.connect(self.onButtonDraw)
        self.button_draw_pcb.move(10, 120)
        self.button_draw_pcb.setEnabled(False)

        self.button_apply_diff = QtGui.QPushButton("Apply diff", self)
        self.button_apply_diff.clicked.connect(self.onButtonApplyDiff)
        self.button_apply_diff.move(120, 120)
        self.button_apply_diff.setEnabled(False)

        self.button_scan_board = QtGui.QPushButton("Scan PCB", self)
        self.button_scan_board.clicked.connect(self.onButtonScanBoard)
        self.button_scan_board.move(10, 180)
        self.button_scan_board.setEnabled(False)

    # ---------------------------------------------------------------------------

    def connectedButtons(self):
        self.text_connection.setText(f"Connected")
        self.text_connection.show()

    def disconnectedButtons(self):
        self.text_connection.hide()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

        self.button_apply_diff.setEnabled(False)
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()

    def serverClosedButtons(self):
        # Disable stop and enable start when server is stopped
        self.button_start_server.setEnabled(False)
        self.button_start_server.hide()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

    def serverStartButtons(self):
        # Enable stop button and disable start when starting server
        self.button_stop_server.setEnabled(True)
        self.button_stop_server.show()
        self.button_start_server.setEnabled(False)
        self.button_start_server.hide()

    # --------------------------------- Button Methods --------------------------------- #
    def onButtonStartServer(self):
        self.startServer()

    def onButtonStopServer(self):
        # logger.debug("Emmiting manual stop signal")
        # print("Emmiting manual stop signal")
        # self.stop_server_signal.emit()

        self.button_start_server.setEnabled(True)
        self.button_start_server.show()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

    def onButtonDraw(self):
        pass

    def onButtonApplyDiff(self):
        if self.pcb and self.diff:
            updatePartFromDiff(self.doc, self.pcb, self.diff)

            self.doc.recompute()
            self.diff = None

    def onButtonScanBoard(self):
        # scanFootprints(doc=self.doc,
        #                pcb=self.pcb)
        # self.doc.recompute()

        self.startPcbScanner()


    # --------------------------------- QThreads --------------------------------- #
    def startServer(self):
        self.server_thread = QtCore.QThread()
        self.server = Server(self.config.host, self.config.port)
        self.server.moveToThread(self.server_thread)

        # Connect signals and slots
        self.server_thread.started.connect(self.server.run)
        self.server.finished.connect(self.server_thread.quit)
        self.server.finished.connect(self.server.deleteLater)
        self.server_thread.finished.connect(self.server_thread.deleteLater)
        # "connected" signal passes Socket.Socket class to startClientThread method for instantiating Connection
        self.server.connected.connect(self.startConnection)
        self.server.progress.connect(self.logServerStatus)
        # Connect a signal to worker slot for communicating back to worker thread (stop server)
        self.stop_server_signal.connect(self.server.workerSlot)

        # Start the thread
        self.server_thread.start()

        # Final resets
        # Enable stop button and disable start when starting server
        self.serverStartButtons()
        # Disable stop end enable start when server is stopped
        self.server_thread.finished.connect(
            lambda: self.serverClosedButtons()
        )

    @staticmethod
    def logServerStatus(status):
        logger.info(f"[SERVER] {status}")
        #print(f"[SERVER] {status}")


    def startConnection(self, connection_socket):
        self.client_thread = QtCore.QThread()
        # Instatiate Connection class with client connection Socket
        self.connection = ConnectionHandler(connection_socket, self.config.header, self.config.format)
        self.connection.moveToThread(self.client_thread)

        # Connecting signals
        self.client_thread.started.connect(self.connection.run)
        self.connection.finished.connect(self.client_thread.quit)
        self.connection.finished.connect(self.connection.deleteLater)
        self.client_thread.finished.connect(self.client_thread.deleteLater)
        self.connection.progress.connect(self.logConnectionStatus)
        # Set and draw PCB signals
        self.connection.received_pcb.connect(self.setPcb)
        self.connection.received_pcb.connect(self.startPcbDrawer)
        # Apply Diff signal
        self.connection.received_diff.connect(self.startPartUpdater)

        # Start handle client thread
        self.client_thread.start()

        # Reset
        self.connectedButtons()
        self.connection.finished.connect(
            lambda: self.disconnectedButtons()
        )

    @staticmethod
    def logConnectionStatus(status):
        logger.info(f"[CONNECTION] {status}")
        #print(f"[CONNECTION] {status}")

    def startPcbDrawer(self):
        self.pcb_drawer_thread = QtCore.QThread()
        self.pcb_drawer = FcPcbDrawer(doc=self.doc,
                                      doc_gui=self.doc_gui,
                                      pcb=self.pcb,
                                      models_path=self.config.models_path)
        self.pcb_drawer.moveToThread(self.pcb_drawer_thread)
        # Signals
        # Connect start signal to run() method
        self.pcb_drawer_thread.started.connect(self.pcb_drawer.run)
        # Finished signal
        self.pcb_drawer.finished.connect(self.pcb_drawer_thread.quit)
        self.pcb_drawer.finished.connect(self.pcb_drawer.deleteLater)
        self.pcb_drawer_thread.finished.connect(self.pcb_drawer_thread.deleteLater)
        # Log signal
        self.pcb_drawer.progress.connect(self.logDrawerProgress)
        # Start thread
        self.pcb_drawer_thread.start()

    @staticmethod
    def logDrawerProgress(status):
        logger.debug(f"[DRAWER] {status}")

    def startPartUpdater(self, diff):
        self.update_thread = QtCore.QThread()
        self.update_obj = FcPartUpdater(doc=self.doc,
                                        pcb=self.pcb,
                                        diff=diff)
        self.update_obj.moveToThread(self.update_thread)
        # Connecting signals
        # Connect start signal to run() method
        self.update_thread.started.connect(self.update_obj.run)
        # Progress signal
        self.update_obj.progress.connect(self.logUpdaterProgress)
        # Finished signal
        self.update_obj.finished.connect(self.update_thread.quit)
        self.update_obj.finished.connect(self.update_obj.deleteLater)
        self.update_thread.finished.connect(self.update_thread.deleteLater)
        # Connect finished signal to setter function for setting new pcb dict
        self.update_obj.finished.connect(self.setPcb)
        # Start apply diff thread
        self.update_thread.start()

    @staticmethod
    def logUpdaterProgress(status):
        logger.debug(f"[UPDATER] {status}")

    def startPcbScanner(self):
        self.scanner_thread = QtCore.QThread()
        self.scanner_obj = FcPcbScanner(doc=self.doc,
                                        pcb=self.pcb)
        self.scanner_obj.moveToThread(self.scanner_thread)

        # Connecting signals
        # Connect start signal to run() method
        self.scanner_thread.started.connect(self.scanner_obj.run)
        # Finished signal
        self.scanner_obj.finished.connect(self.finishedPcbScanner)
        self.scanner_obj.finished.connect(self.scanner_thread.quit)
        self.scanner_obj.finished.connect(self.scanner_obj.deleteLater)
        self.scanner_thread.finished.connect(self.scanner_thread.deleteLater)
        self.scanner_thread.finished.connect(self.refreshDocument)
        # Connect log signal
        self.scanner_obj.progress.connect(self.logScannerProgress)
        # Start thread
        self.scanner_thread.start()

    @staticmethod
    def logScannerProgress(status):
        logger.info(f"[SCANNER] {status}")

    @staticmethod
    def finishedPcbScanner(diff):
        # Print pcb data to json file
        with open(directory_path + "/Logs/diff.json", "w") as f:
            json.dump(diff, f, indent=4)

    def refreshDocument(self):
        self.doc.recompute()

    # ---------------------------------------------------------------------------------

    def setPcb(self, data):
        self.pcb = data
        logger.debug(f"[HOST] PCB Dictionary set: {self.pcb}")
        self.button_draw_pcb.setEnabled(True)
        self.button_scan_board.setEnabled(True)


    # def closeSocket(self):
    #     print("Closing connection manually")
    #     self.Socket.close()
    #
    #     self.button_start_server.setEnabled(True)
    #     self.button_start_server.show()
    #     self.button_stop_server.setEnabled(False)
    #     self.button_stop_server.hide()


    def sendMessage(self, msg):
        # Calculate length of first message
        msg_length = len(msg)
        send_length = str(msg_length).encode(self.config.format)
        # Pad first message
        send_length += b' ' * (self.config.header - len(send_length))
        # Send length end object
        self.conn.send(send_length)
        self.conn.send(msg.encode(self.config.format))


# Instantiate host plugin
host_plugin = FreeCadHost()
# Add the widget to the main window right area
Gui.getMainWindow().addDockWidget(QtCore.Qt.RightDockWidgetArea, host_plugin)