""" Instantiates main plugin class and adds it as a widget to main window. """

import FreeCAD as App
import FreeCADGui as Gui

import configparser
import hashlib
import json
import logging
import logging.config
import os
import sys

from PySide import QtGui, QtCore

from API_scripts.part_scanner import FcPcbScanner
from API_scripts.part_drawer import FcPartDrawer
from API_scripts.part_updater import FcPartUpdater
from Config.config_loader import ConfigLoader
from Socket.server import Server, ConnectionHandler


# Get the path to log file because configparsed doesn't search for the file in same directory where module is saved
# in file system. (it searches in directory where script is executed)
directory_path = os.path.dirname(os.path.realpath(__file__))
# Backslash is replaced with forwardslash, otherwise the file paths don't work
logging_config_file = os.path.join(directory_path, "Config", "logging.ini").replace("\\", "/")
# Define directory path for /Logs
log_files_directory = os.path.join(directory_path, "Logs").replace("\\", "/")
# Configure logging module with .ini file, pass /Logs directory as argument (part of formatted string in .ini)
logging.config.fileConfig(logging_config_file, defaults={"log_directory": log_files_directory})

# Initialize logger and log basic system info:
logger = logging.getLogger()
logger.info("Plugin executed on: " + repr(sys.platform))
logger.info("Plugin executed with python version: " + repr(sys.version))
logger.info("FreeCAD build version: " + str(App.Version()))

# Button placement magic values
FIRST_COLUMN_X = 10
SECOND_COLUMN_X = 120
INITIAL_Y = 120
OFFSET_Y = 60


class FreeCadHost(QtGui.QDockWidget):
    """ Main plugin class. """
    # # QT signal for stopping server in worker thread
    # stop_server_signal = QtCore.Signal()

    def __init__(self):
        super().__init__()

        # Get FreeCAD document and GUI objects
        self.doc = App.activeDocument()
        self.doc_gui = Gui.ActiveDocument

        # Initialize dictionary variables
        self.pcb = {}
        self.diff = {}

        # Get config.ini file path
        config_file = os.path.join(directory_path, "Config", "config.ini").replace("\\", "/")
        # Load config data
        # TODO why is this a config class?
        self.config = ConfigLoader(config_file)
        logger.info(f"Loaded configuration: {self.config.getConfig()}")

        # Set up the User Interface
        self.setupUi()

    def setupUi(self):
        """ Set up buttons and text. """
        self.setObjectName("FreeCAD Host")
        self.resize(QtCore.QSize(300, 100).expandedTo(self.minimumSizeHint()))  # sets size of the widget

        # Text
        self.text_connection = QtGui.QLabel("", self)
        self.text_connection.move(30, 25)
        self.text_connection.resize(180, 25)
        self.text_connection.hide()

        self.text_controls = QtGui.QLabel("Object controls:", self)
        self.text_controls.move(10, 90)

        # Buttons
        self.button_start_server = QtGui.QPushButton("Accept new connection", self)
        self.button_start_server.clicked.connect(self.onButtonStartServer)
        self.button_start_server.move(25, 25)
        self.button_start_server.resize(180, 25)

        self.button_stop_server = QtGui.QPushButton("Stop listening", self)
        self.button_stop_server.clicked.connect(self.onButtonStopServer)
        self.button_stop_server.hide()
        self.button_stop_server.move(25, 25)
        self.button_stop_server.resize(180, 25)
        self.button_stop_server.setEnabled(False)

        self.button_request_pcb = QtGui.QPushButton("Accept PCB", self)
        self.button_request_pcb.clicked.connect(self.onButtonRequestPcb)
        self.button_request_pcb.move(FIRST_COLUMN_X, INITIAL_Y)
        self.button_request_pcb.setEnabled(False)

        self.button_attach_pcb = QtGui.QPushButton("Attach PCB", self)
        self.button_attach_pcb.clicked.connect(self.onButtonAttachPcb)
        self.button_attach_pcb.move(SECOND_COLUMN_X, INITIAL_Y)
        self.button_attach_pcb.setEnabled(False)

        self.button_sync = QtGui.QPushButton("Sync", self)
        self.button_sync.clicked.connect(self.onButtonSync)
        self.button_sync.move(FIRST_COLUMN_X, INITIAL_Y + OFFSET_Y)
        self.button_sync.setEnabled(False)


    # --------------------------------- Button Methods --------------------------------- #
    def onButtonStartServer(self):
        """ Call method on button press. """
        self.startServer()

    def onButtonStopServer(self):
        """ Call stop method (in another thread) to queue abort. """
        self.server.stop()
        # Set appropriate button visibility
        self.serverClosedButtons()

    def onButtonRequestPcb(self):
        """ Call method on button press. """
        self.requestPcb()

    def onButtonAttachPcb(self):
        """ Call method on button press. """
        self.attachPcb()

    def onButtonSync(self):
        """ Call method on button press. """
        self.requestDiff()


    # --------------------------------- Hide/Show Buttons --------------------------------- #

    def connectedButtons(self):
        """ Change large button text and visibility. """
        self.text_connection.setText(f"Connected")
        self.text_connection.show()
        self.button_stop_server.hide()
        self.button_start_server.hide()
        # Enable buttons for requesting pcb or attaching pcb
        self.button_request_pcb.setEnabled(True)
        self.button_attach_pcb.setEnabled(True)

    def disconnectedButtons(self):
        """ Change large button text and visibility. """
        self.text_connection.hide()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

        self.button_sync.setEnabled(False)
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()

    def serverClosedButtons(self):
        """ Disable stop and enable start when server is stopped. """
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

    def serverStartButtons(self):
        """ Enable stop button and disable start when starting server. """
        self.button_start_server.setEnabled(False)
        self.button_start_server.hide()
        self.button_stop_server.setEnabled(True)
        self.button_stop_server.show()

    # ---------------------------------| Sequential Process Methods |--------------------------------- #

    def startServer(self):
        """ 1. step: Start server in a new thread. Thread is stopped and deleted when connection to client occurs. """
        self.server_thread = QtCore.QThread()
        self.server = Server(self.config)
        self.server.moveToThread(self.server_thread)

        # Connect signals and slots
        self.server_thread.started.connect(self.server.run)
        self.server.finished.connect(self.server_thread.quit)
        self.server.finished.connect(self.server.deleteLater)
        self.server_thread.finished.connect(self.server_thread.deleteLater)
        # Connect finished signal to startConnection method - this passes socket.socket object to ConnectionHandler
        self.server.finished.connect(self.onServerFinished)

        # Start the thread
        self.server_thread.start()
        # Enable stop button and disable start when starting server
        self.serverStartButtons()

    def onServerFinished(self, server_response):
        """ 2. step: Attach socket objects to self. """
        # Get data from dictionary type
        status = server_response.get("status")

        # Perform check if connection is real or fake (quasy-abort) see Server class doctring
        if status == "abort":
            logger.debug("Server aborted, ignoring connection socket")
            # Show correct button configuration - server was aborted, enable button for starting server again
            self.serverClosedButtons()

        elif status == "exception":
            logger.error(f"Exception when starting server")

        elif status == "client_connected":
            # Get data from dictionary type
            connection_socket = server_response.get("connection_socket")
            # Attach connection handle (socket) to class, so that a message can be sent manually by button (sendMessage)
            self.socket = connection_socket
            # Change button visibility
            self.connectedButtons()
            logger.debug("Client connected.")

    def attachPcb(self):
        """ Read .JSON property of Part object and register it as pcb data model instead of requesting it from KC. """
        # Disable button for requesting pcb from KiCAD (since pcb data model is going to be attached)
        self.button_request_pcb.setEnabled(False)
        # TODO exiting FC part must be selected.
        #  Read .JSON property of this part (which is data model of the part)
        #  attach is as self.pcb

    def requestPcb(self):
        """ 3. step: send a request message over socket, listen for reply in a new thread. """
        self.button_request_pcb.setEnabled(False)
        # Send message to request pcb from KiCAD
        self.sendMessage("blankmessage", msg_type="REQPCB")

        # Run ConnectioHandler in a new thread to listen for replies
        self.connection_thread = QtCore.QThread()
        # Instatiate Connection class with client connection Socket
        self.connection = ConnectionHandler(self.socket, self.config)
        self.connection.moveToThread(self.connection_thread)
        # Connecting signals:
        # Finished signal
        self.connection_thread.started.connect(self.connection.run)
        self.connection.finished.connect(self.connection_thread.quit)
        self.connection.finished.connect(self.connection.deleteLater)
        self.connection_thread.finished.connect(self.connection_thread.deleteLater)
        self.connection.finished.connect(self.onConnectionHandlerFinished)
        # Custom signals
        self.connection.received_pcb.connect(self.onReceivedPcb)
        self.connection.received_diff.connect(self.onReceivedDiff)
        self.connection.received_diff_reply.connect(self.onReceivedDiffReply)
        # Start thread
        self.connection_thread.start()

    def onReceivedPcb(self, pcb_data):
        """ 4. step: call function to draw part object when data model is received. """
        # Attach dictionary to object
        self.pcb = pcb_data
        self.startPartDrawer()

    def onPcbDrawerFinished(self):
        """ 5. step: Called when drawer is finished, enables Sync button. """
        # Enable Sync button.
        self.button_sync.setEnabled(True)

    def requestDiff(self):
        """ 6. step: Send request message when user presses SYNC button. """
        logger.info("Sending request message.")
        # Send request message
        self.sendMessage("blankmessage", msg_type="REQDIF")

    def onReceivedDiff(self, diff_data: dict):
        """ 7. step: start PartScanner in a seperate thread to get local Diff """
        # Attach received data to object
        self.kc_diff = diff_data
        # Call PartScanner to get local Diff
        self.startPartScanner()

    def onPartScannerFinished(self, local_diff):
        """ 8. step: merge local Diff and received Diff. Prioritise FC drawings and KC footprints if conflicting. """

        logger.info(f"PartScanner finished {local_diff}")
        merged_diff = {}

        # Select which drawings diff to use:
        fc_drawings = local_diff.get("drawings")
        kc_drawings = self.kc_diff.get("drawings")
        # Use FC drawings if FC Diff has drawings
        drawings = fc_drawings if fc_drawings else kc_drawings
        # Can be None if neither FC nor KC have drawings
        if drawings:
            merged_diff.update({"drawings": drawings})

        # Select which footprints diff to use:
        fc_footprints = local_diff.get("footprints")
        kc_footprints = self.kc_diff.get("footprints")
        # Use KC footprints if KC Diff has footprints
        footprints = kc_footprints if kc_footprints else fc_footprints
        # Can be None if neither FC nor KC have footprints
        if footprints:
            merged_diff.update({"footprints": footprints})

        logger.info(f"Diff merged: {merged_diff}")
        self.dumpToJsonFile(merged_diff, "/Logs/diff.json")
        # Attach diff to object
        self.diff = merged_diff
        # Send new diff to KiCAD
        self.sendMessage(json.dumps(merged_diff), msg_type="DIF")

    def onReceivedDiffReply(self, diff_reply, hash_data):
        """
        9. step: apply diff. diff_reply contains merged diff which was sent to FC before and also updated KIID
        if new drawings were added in FC.
        Hash data is hashed KC data model used to check sync on FC side after updating.
        """
        # Attach received values to object
        self.diff = diff_reply
        self.kc_hash = hash_data
        logger.info(f"Received reply: {self.diff},\nHash: {hash_data}")
        self.dumpToJsonFile(self.diff, "/Logs/diff.json")
        # Update FC Part objects
        self.startPartUpdater(self.diff)

    def onPartUpdaterFinished(self):
        """ 10: step: compare hashes of both data models to confirm sync. """
        logger.info(f"Finished part updater")
        # Write data model to file for debugging purposes
        self.dumpToJsonFile(self.pcb, "/Logs/data_indent.json")

        pcb_hash = hashlib.md5(str(self.pcb).encode()).hexdigest()
        if pcb_hash == self.kc_hash:
            logger.info(f"Hash match!")
            logger.debug(f"Clearing Diff")
            self.diff = {}
        else:
            logger.error(f"Hash mismatch!\n{pcb_hash} should be {self.kc_hash}")
            # TODO handle mismatch case!

    # noinspection PyUnusedLocal
    def onConnectionHandlerFinished(self, event):
        """ Function must accept event argument to be triggered. """
        self.disconnectedButtons()


    # ------------------------------------| API methods |--------------------------------------------- #
    # Method that start classes with FreeCAD API functionality in new threads.

    def startPartDrawer(self):
        """ Stars Drawer in another thread to avoid crashing FreeCAD."""
        self.pcb_drawer_thread = QtCore.QThread()
        self.pcb_drawer = FcPartDrawer(doc=self.doc,
                                       # doc_gui=self.doc_gui,
                                       pcb=self.pcb,
                                       models_path=self.config.models_path)
        self.pcb_drawer.moveToThread(self.pcb_drawer_thread)
        # Connect signals
        self.pcb_drawer_thread.started.connect(self.pcb_drawer.run)
        # Finished signal
        self.pcb_drawer.finished.connect(self.pcb_drawer_thread.quit)
        self.pcb_drawer.finished.connect(self.pcb_drawer.deleteLater)
        self.pcb_drawer_thread.finished.connect(self.pcb_drawer_thread.deleteLater)
        # Connect finished signal to trigger a method
        self.pcb_drawer.finished.connect(self.onPcbDrawerFinished)
        # Log signal
        self.pcb_drawer.progress.connect(self.logDrawerProgress)
        logger.info(f"Starting PartDrawer")
        # Start thread
        self.pcb_drawer_thread.start()

    @staticmethod
    def logDrawerProgress(status: str):
        """
        This function exist because when logging in pcb_drawer module FC crashed.
        Log is passed by signal and logged here.
        """
        logger.debug(f"[DRAWER] {status}")

    def startPartScanner(self):
        """ Starts Drawer in another thread to avoid crashing FreeCAD."""
        self.scanner_thread = QtCore.QThread()
        self.scanner_obj = FcPcbScanner(doc=self.doc,
                                        pcb=self.pcb,
                                        diff=self.diff)
        self.scanner_obj.moveToThread(self.scanner_thread)

        # Connecting signals
        # Connect start signal to run() method
        self.scanner_thread.started.connect(self.scanner_obj.run)
        # Finished signal
        self.scanner_obj.finished.connect(self.scanner_thread.quit)
        self.scanner_obj.finished.connect(self.scanner_obj.deleteLater)
        self.scanner_thread.finished.connect(self.scanner_thread.deleteLater)
        # Connect finished signal to trigger a method
        self.scanner_obj.finished.connect(self.onPartScannerFinished)
        # Start thread
        logger.info(f"Starting PartScanner")
        self.scanner_thread.start()

    def startPartUpdater(self, diff: dict):
        """ Starts Drawer in another thread to avoid crashing FreeCAD."""
        self.update_thread = QtCore.QThread()
        self.update_obj = FcPartUpdater(doc=self.doc,
                                        pcb=self.pcb,
                                        diff=diff)
        self.update_obj.moveToThread(self.update_thread)
        # Connecting signals
        # Connect start signal to run() method
        self.update_thread.started.connect(self.update_obj.run)
        # Finished signal
        self.update_obj.finished.connect(self.update_thread.quit)
        self.update_obj.finished.connect(self.update_obj.deleteLater)
        self.update_thread.finished.connect(self.update_thread.deleteLater)
        # Connect finished signal to trigger a method
        self.update_obj.finished.connect(self.onPartUpdaterFinished)
        logger.info(f"Starting PartUpdater")
        # Start thread
        self.update_thread.start()

    # ------------------------------------| Utils |--------------------------------------------- #

    def sendMessage(self, msg: str, msg_type: str = "!DIS"):
        """
        Message can be type (by convention) of !DIS, REQ_PCB, REQ_DIF, PCB, DIF
        :param msg: json encoded string
        :param msg_type: str
        :return:
        """
        logger.debug(f"Sending message {msg_type}_{msg}")
        # Calculate length of first message
        msg_length = len(msg)
        send_length = str(msg_length)
        # First message is type and length of second message
        first_message = f"{msg_type}_{send_length}".encode(self.config.format)
        # Pad first message
        first_message += b' ' * (self.config.header - len(first_message))
        # Send length and object
        self.socket.send(first_message)
        self.socket.send(msg.encode(self.config.format))

    def refreshDocument(self):
        """ Recompute FreeCAD Document object. """
        logger.info(f"Recomputing document")
        self.doc.recompute()

    @staticmethod
    def dumpToJsonFile(data, filename: str):
        """ Save data to file. """
        with open(directory_path + filename, "w") as f:
            json.dump(data, f, indent=4)


# ===========================================| FCMacro |=========================================== #

# Instantiate host plugin
host_plugin = FreeCadHost()
# Add the widget to the main window right area
Gui.getMainWindow().addDockWidget(QtCore.Qt.RightDockWidgetArea, host_plugin)