# noinspection PyUnresolvedReferences
import Draft
import FreeCAD as App
import FreeCADGui as Gui
import Import
import ImportGui
import Part
import PartDesignGui

import json
import dictdiffer
import pickle
import sys
import Sketcher
import socket
import threading

from PySide import QtGui, QtCore


SCALE = 1000000
# TODO user configurable path
MODELS_PATH = u"C:/Program Files/KiCad/7.0/share/kicad/3dmodels"
# Dictionary of rotations vectors
VEC = {"x": App.Vector(1, 0, 0),
       "y": App.Vector(0, 1, 0),
       "z": App.Vector(0, 0, 1),
       "0": App.Vector(0, 0, 0)}


# noinspection PyShadowingNames
def importModel(model, fp, fp_part, doc, pcb, MODELS_PATH):
    """
    Import .step models to document as children of footprint Part container
    :param model: dictioneray with model properties
    :param fp: footprint dictionary
    :param fp_part: FreeCAD App::Part object
    :param doc: FreeCAD document object
    :param pcb: pcb dictionary
    :param MODELS_PATH: string (models directory path)
    :return:
    """
    pcb_id = pcb["general"]["pcb_id"]

    # Import model
    path = MODELS_PATH + model["filename"] + ".step"
    ImportGui.insert(path, doc.Name)

    # Last obj in doc is imported model
    feature = doc.Objects[-1]
    # Set label
    feature.Label = f"{fp['flag']}_{fp['ref']}_{model['model_id']}_{pcb_id}"
    feature.addProperty("App::PropertyString", "Filename", "Base")
    feature.Filename = model["filename"].split("/")[-1]
    feature.addProperty("App::PropertyBool", "Model", "Base")
    feature.Model = True

    # Model is child of fp - inherits base coordinates, only offset necessary
    # Offset unit is mm, y is not flipped:
    offset = App.Vector(model["offset"][0],
                        model["offset"][1],
                        model["offset"][2])
    feature.Placement.Base = offset

    # Check if model needs to be rotated
    if model["rot"] != [0.0, 0.0, 0.0]:
        feature.Placement.rotate(VEC["0"], VEC["x"], -model["rot"][0])
        feature.Placement.rotate(VEC["0"], VEC["y"], -model["rot"][1])
        feature.Placement.rotate(VEC["0"], VEC["z"], -model["rot"][2])

    # If footprint is on bottom layer:
    # rotate model 180 around x and move in -z by pcb thickness
    if fp["layer"] == "Bot":
        feature.Placement.Rotation = App.Rotation(VEC["x"], 180.00)
        feature.Placement.Base.z = -(pcb["general"]["thickness"] / SCALE)

    # Scale model if it's not 1x
    if model["scale"] != [1.0, 1.0, 1.0]:
        # Make clone with Draft module in order to scale shape
        clone = Draft.make_clone(feature, delta=offset)
        clone.Scale = App.Vector(model["scale"][0],
                                 model["scale"][1],
                                 model["scale"][2])
        # Rename original: add "_o_"
        feature.Label = f"{fp['flag']}_{fp['ref']}_{model['model_id']}_o_{pcb_id}"
        # Add clone name without "_o_"
        clone.Label = f"{fp['flag']}_{fp['ref']}_{model['model_id']}_{pcb_id}"
        clone.addProperty("App::PropertyString", "Filename", "Base")
        clone.Filename = model["filename"].split("/")[-1]
        clone.addProperty("App::PropertyBool", "Model", "Base")
        clone.Model = True
        # Hide original
        feature.Visibility = False
        fp_part.addObject(clone)
        # Both feature and clone must be in footprint part containter for clone to work

    fp_part.addObject(feature)


def addFootprintPart(fp, doc, pcb):
    """
    Adds footprint container to "Top" or "Bot" Group of "Footprints"
    Imports Step models as childer
    Add "Pads" container with through hole pads - add holes to sketch as circles
    :param fp: footprint dictionary
    :param doc: FreeCAD document object
    :param pcb: pcb dictionary
    :return:
    """
    pcb_id = pcb["general"]["pcb_id"]
    sketch = doc.getObject(f"Board_Sketch_{pcb_id}")

    # Crate a part object for each footprint
    # naming: " flag_ref_id "  so there is no auto-self-naming duplicates
    fp_part = doc.addObject("App::Part", f"{fp['flag']}_{fp['ref']}_{pcb_id}")
    fp_part.Label = f"{fp['flag']}_{fp['ref']}_{pcb_id}"
    # Add property reference, which is same as label
    fp_part.addProperty("App::PropertyString", "Reference", "Base")
    fp_part.Reference = fp["ref"]
    # Add flag (KiCAD ID)
    fp_part.addProperty("App::PropertyInteger", "Flag", "Base")
    fp_part.Flag = fp["flag"]

    # Add to layer part
    if fp["layer"] == "Top":
        doc.getObject(f"Top_{pcb_id}").addObject(fp_part)
    else:
        doc.getObject(f"Bot_{pcb_id}").addObject(fp_part)

    # Footprint placement
    base = App.Vector(fp["pos"][0] / SCALE,
                      -fp["pos"][1] / SCALE,
                      0)
    fp_part.Placement.Base = base
    # Footprint rotation around z axis
    fp_part.Placement.rotate(VEC["0"], VEC["z"], fp["rot"])

    # Check if fp has through hole
    if fp.get("pads_pth"):
        pad_part = doc.addObject("App::Part", f"Pads_{fp_part.Label}")
        pad_part.Visibility = False
        fp_part.addObject(pad_part)
        for pad in fp["pads_pth"]:
            maj_axis = pad["hole_size"][0] / SCALE
            min_axis = pad["hole_size"][1] / SCALE
            center = App.Vector((fp["pos"][0] + pad["pos_delta"][0]) / SCALE,
                                -(fp["pos"][1] + pad["pos_delta"][1]) / SCALE,
                                0)
            circle = Part.Circle(Center=center,
                                 Normal=VEC["z"],
                                 Radius=float(maj_axis) / 2)
            # Add ellipse to sketch
            sketch.addGeometry(circle, False)
            sketch.addConstraint(Sketcher.Constraint('Radius',
                                                     (sketch.GeometryCount - 1),
                                                     (maj_axis / 2)
                                                     )
                                 )

            # Create an object to store Tag and Delta
            obj = doc.addObject("Part::Feature", f"{fp['ref']}_{pad['pad_name']}_{pcb_id}")
            obj.Shape = circle.toShape()
            obj.addProperty("App::PropertyString", "Tag", "Sketch")
            # Add Tag after its added to sketch!
            obj.Tag = sketch.Geometry[-1].Tag
            # Store position delta, which is used when moving geometry in sketch
            obj.addProperty("App::PropertyVector", "PosDelta")
            obj.PosDelta = center - base
            obj.addProperty("App::PropertyFloat", "Radius")
            obj.Radius = maj_axis / 2
            # Save constraint index (used for modifying hole size when applying diff)
            obj.addProperty("App::PropertyInteger", "Constraint", "Sketch")
            obj.Constraint = sketch.ConstraintCount - 1
            obj.Visibility = False
            pad_part.addObject(obj)

    # Check fp for 3D models
    if fp.get("3d_models"):
        for model in fp["3d_models"]:
            # Import model - call function
            importModel(model, fp, fp_part, doc, pcb, MODELS_PATH)


def drawPcb(doc, doc_gui, pcb):
    """
    Creates PCB from dictionary as Part object in FC
    :param doc: FreeCAD document object
    :param doc_gui: FreeCAD Document GUI object
    :param pcb: pcb dictionary, from which to generate PCB part
    :return: FreeCAD Part object
    """
    # Draft need to be activated
    Gui.activateWorkbench("DraftWorkbench")

    try:  # Delete pcb object with same name if it exists
        obj = doc.getObject(pcb["general"]["pcb_name"] + "_" + pcb["general"]["pcb_id"])
        obj.removeObjectsFromDocument()
        doc.removeObject(obj.Label)
        doc.recompute()
    except AttributeError:
        pass

    if not doc:
        doc = App.newDocument("Unnamed")

    # Create parent part
    pcb_part = doc.addObject("App::Part", pcb["general"]["pcb_name"] + "_" + pcb["general"]["pcb_id"])
    pcb_id = pcb["general"]["pcb_id"]
    # Add entire JSON file string as property of parent part
    pcb_part.addProperty("App::PropertyString", "JSON", "Data")
    pcb_part.JSON = str(pcb)

    board_geoms_part = doc.addObject("App::Part", f"Board_Geoms_{pcb_id}")
    pcb_part.addObject(board_geoms_part)

    drawings_part = doc.addObject("App::Part", f"Drawings_{pcb_id}")
    drawings_part.Visibility = False
    board_geoms_part.addObject(drawings_part)

    sketch = doc.addObject("Sketcher::SketchObject", f"Board_Sketch_{pcb_id}")
    board_geoms_part.addObject(sketch)

    # -----------------------------------------| EDGE CUTS | -----------------------------------------
    for edge in pcb["geometry"]:
        # Create an object to store Tag
        obj = doc.addObject("Part::Feature", f"{edge['shape']}_{pcb_id}")
        obj.addProperty("App::PropertyStringList", "Tags", "Base")
        obj.Visibility = False
        drawings_part.addObject(obj)

        if ("Rect" in edge["shape"]) or ("Polygon" in edge["shape"]):
            points, tags = [], []
            for i, p in enumerate(edge["points"]):
                point = App.Vector(p[0] / SCALE,
                                   -p[1] / SCALE,
                                   0)
                if i != 0:
                    # Create a line from current to previous point
                    sketch.addGeometry(Part.LineSegment(point, points[-1]), False)
                    tags.append(sketch.Geometry[-1].Tag)

                points.append(point)

            # Add another line from last to first point
            sketch.addGeometry(Part.LineSegment(points[-1], points[0]), False)
            tags.append(sketch.Geometry[-1].Tag)
            # Add Tag after its added to sketch
            obj.Tags = tags

        if "Line" in edge["shape"]:
            start = App.Vector(edge["start"][0] / SCALE,
                               -edge["start"][1] / SCALE,
                               0)
            end = App.Vector(edge["end"][0] / SCALE,
                             -edge["end"][1] / SCALE,
                             0)
            line = Part.LineSegment(start, end)
            # Add line to sketch
            sketch.addGeometry(line, False)
            # Add Tag after its added to sketch
            obj.Tags = sketch.Geometry[-1].Tag

        elif "Arc" in edge["shape"]:
            p1 = App.Vector(edge["p1"][0] / SCALE,
                            -edge["p1"][1] / SCALE,
                            0)
            p2 = App.Vector(edge["p2"][0] / SCALE,
                            -edge["p2"][1] / SCALE,
                            0)

            p3 = App.Vector(edge["p3"][0] / SCALE,
                            -edge["p3"][1] / SCALE,
                            0)

            arc = Part.ArcOfCircle(p1, p2, p3)
            # Add arc to sketch
            sketch.addGeometry(arc, False)
            # Add Tag after its added to sketch
            obj.Tags = sketch.Geometry[-1].Tag

        elif "Circle" in edge["shape"]:
            radius = edge["radius"] / SCALE
            center = App.Vector(edge["center"][0] / SCALE,
                                -edge["center"][1] / SCALE,
                                0)
            circle = Part.Circle(Center=center,
                                 Normal=VEC["z"],
                                 Radius=radius)
            # Add circle to sketch
            sketch.addGeometry(circle, False)
            sketch.addConstraint(
                Sketcher.Constraint('Radius',
                                    (sketch.GeometryCount - 1),
                                    radius
                                    ))
            # Add Tag after its added to sketch
            obj.Tags = sketch.Geometry[-1].Tag
            obj.addProperty("App::PropertyFloat", "Radius")
            obj.Radius = radius

    # -----------------------------------------| VIAs | -----------------------------------------
    vias_part = doc.addObject("App::Part", f"Vias_{pcb_id}")
    vias_part.Visibility = False
    board_geoms_part.addObject(vias_part)
    for via in pcb["vias"]:
        radius = via["hole_size"] / SCALE
        center = App.Vector(via["pos"][0] / SCALE,   # x
                            -via["pos"][1] / SCALE,  # y
                            0)                       # z
        # placement = App.Placement(center, App.Rotation(VEC["z"], 0))
        circle = Part.Circle(Center=center,
                             Normal=VEC["z"],
                             Radius=radius)
        # Add circle to sketch
        sketch.addGeometry(circle, False)
        sketch.addConstraint(
            Sketcher.Constraint('Radius',
                                (sketch.GeometryCount - 1),
                                radius
                                ))
        # Create an object to store Tag
        obj = doc.addObject("Part::Feature", f"{via['via_id']}_{pcb_id}")
        obj.Shape = circle.toShape()
        obj.addProperty("App::PropertyString", "Tag", "Base")
        # Add Tag after its added to sketch
        obj.Tag = sketch.Geometry[-1].Tag
        obj.addProperty("App::PropertyFloat", "Radius")
        obj.Radius = radius
        obj.Visibility = False
        vias_part.addObject(obj)

    # -----------------------------------------| EXTRUDE | -----------------------------------------
    pcb_extr = doc.addObject('Part::Extrusion', f"Board_{pcb_id}")
    board_geoms_part.addObject(pcb_extr)
    pcb_extr.Base = sketch
    pcb_extr.DirMode = "Normal"
    pcb_extr.DirLink = None
    pcb_extr.LengthFwd = -(pcb["general"]["thickness"] / SCALE)
    pcb_extr.LengthRev = 0
    pcb_extr.Solid = True
    pcb_extr.Reversed = False
    pcb_extr.Symmetric = False
    pcb_extr.TaperAngle = 0
    pcb_extr.TaperAngleRev = 0
    pcb_extr.ViewObject.ShapeColor = getattr(doc.getObject(f"Board_{pcb_id}").getLinkedObject(True).ViewObject,
                                             'ShapeColor', pcb_extr.ViewObject.ShapeColor)
    pcb_extr.ViewObject.LineColor = getattr(doc.getObject(f"Board_{pcb_id}").getLinkedObject(True).ViewObject,
                                            'LineColor', pcb_extr.ViewObject.LineColor)
    pcb_extr.ViewObject.PointColor = getattr(doc.getObject(f"Board_{pcb_id}").getLinkedObject(True).ViewObject,
                                             'PointColor', pcb_extr.ViewObject.PointColor)
    # Set extrude pcb color to HTML #339966
    doc_gui.getObject(pcb_extr.Label).ShapeColor = (0.20000000298023224, 0.6000000238418579, 0.4000000059604645, 0.0)

    sketch.Visibility = False

    # -----------------------------------------| FOOTPRINTS | -----------------------------------------
    # Create Footprint container and add it to PCB Part
    footprints_part = doc.addObject("App::Part", f"Footprints_{pcb_id}")
    pcb_part.addObject(footprints_part)
    # Create Top and Bot containers and add them to Footprints container
    fps_top_part = doc.addObject("App::Part", f"Top_{pcb_id}")
    fps_bot_part = doc.addObject("App::Part", f"Bot_{pcb_id}")
    footprints_part.addObject(fps_top_part)
    footprints_part.addObject(fps_bot_part)

    for fp in pcb["footprints"]:
        addFootprintPart(fp, doc, pcb)

    doc.recompute()
    # Hide grid from Draft module
    Gui.runCommand("Draft_ToggleGrid")
    Gui.SendMsgToActiveView("ViewFit")

    return pcb_part


def updatePartFromDiff(doc, pcb, diff):
    pcb_id = pcb["general"]["pcb_id"]

    if diff["footprints"]:
        changed = diff["footprints"].get("changed")
        added = diff["footprints"].get("added")
        removed = diff["footprints"].get("removed")

        if added:
            for fp in added:
                addFootprintPart(fp, doc, pcb)
                pcb["footprints"].append(fp)

        if removed:
            for flag in removed:
                # Get footprint in dictionary
                for fp in pcb["footprints"]:
                    if fp["flag"] == flag:
                        # Find corresponding FC object by flag
                        for layer in doc.getObject(f"Footprints_{pcb_id}").Group:
                            for fp_part in layer.Group:
                                if fp_part.Flag == flag:

                                    # Remove through holes from sketch
                                    for child in fp_part.Group:
                                        if "Pads" in child.Label:
                                            sketch = doc.getObject(f"Board_Sketch_{pcb_id}")
                                            for pad in child.Group:
                                                counter = 0
                                                for index, geom in enumerate(sketch.Geometry):
                                                    # Find corresponding geometry in sketch
                                                    if geom.Tag == pad.Tag:
                                                        # Delete geometry by index (account for list shift with counter)
                                                        sketch.delGeometries([index-counter])
                                                        counter += 1

                                    # Delete FP Part container
                                    doc.getObject(fp_part.Name).removeObjectsFromDocument()
                                    doc.removeObject(fp_part.Name)
                                    doc.recompute()

                                    # Remove from dictionary
                                    pcb["footprints"].remove(fp)

        if changed:
            for entry in changed:
                items = [[x, y] for x, y in entry.items()]
                flag = items[0][0]
                changes = items[0][1]

                # Get footprint in dictionary
                for fp in pcb["footprints"]:
                    if str(fp["flag"]) == flag:
                        # Find corresponding FC object by flag
                        for layer in doc.getObject(f"Footprints_{pcb_id}").Group:
                            for fp_part in layer.Group:
                                if str(fp_part.Flag) == str(flag):

                                    for c in changes:
                                        prop, value = c[0], c[1]
                                        sketch = doc.getObject(f"Board_Sketch_{pcb_id}")

                                        if prop == "ref":
                                            fp_part.Reference = value
                                            fp.update({"ref": value})
                                            fp_part.Label = f"{fp['flag']}_{fp['ref']}_{pcb_id}"

                                        elif prop == "pos":
                                            # Move footprint to new position
                                            base = App.Vector(value[0] / SCALE,
                                                              -value[1] / SCALE,
                                                              0)
                                            fp_part.Placement.Base = base
                                            fp.update({"pos": value})

                                            # Move holes in sketch to new position
                                            if fp["pads_pth"] and sketch:
                                                # Group[0] is pad_part container of footprint part
                                                for pad in fp_part.Group[0].Group:
                                                    # Find geometry in sketch with same Tag
                                                    for index, geom in enumerate(sketch.Geometry):
                                                        if geom.Tag == pad.Tag:
                                                            # Get delta from feature obj
                                                            delta = App.Vector(pad.PosDelta[0],
                                                                               pad.PosDelta[1],
                                                                               pad.PosDelta[2])
                                                            # Move point to new footprint pos
                                                            # (account for previous pad delta)
                                                            sketch.movePoint(index, 3, base + delta)

                                        elif prop == "rot":
                                            fp_part.Placement.rotate(VEC["0"],
                                                                     VEC["z"],
                                                                     value-fp["rot"])
                                            fp.update({"rot": value})

                                        elif prop == "layer":
                                            # Remove from parent
                                            parent = fp_part.Parents[0][1].split(".")[1]
                                            doc.getObject(parent).removeObject(fp_part)
                                            # Add to new layer
                                            new_layer = f"{value}_{pcb_id}"
                                            doc.getObject(new_layer).addObject(fp_part)
                                            # Update dictionary
                                            fp.update({"layer": value})

                                            # Top -> Bottom
                                            # rotate model 180 around x and move in -z by pcb thickness
                                            if value == "Bot":
                                                for feature in fp_part.Group:
                                                    if "Pads" in feature.Label:
                                                        continue
                                                    feature.Placement.Rotation = App.Rotation(VEC["x"], 180.00)
                                                    feature.Placement.Base.z = -(pcb["general"]["thickness"] / SCALE)
                                            # Bottom -> Top
                                            if value == "Top":
                                                for feature in fp_part.Group:
                                                    if "Pads" in feature.Label:
                                                        continue
                                                    feature.Placement.Rotation = App.Rotation(VEC["x"], 0.0)
                                                    feature.Placement.Base.z = 0

                                        elif prop == "pads_pth" and sketch:
                                            # Go through list if dictionaries ( "pad_name": [*list of changes*])
                                            for val in value:
                                                for name, changes in val.items():
                                                    # Get pad by name
                                                    pad_obj = doc.getObject(f"{fp_part.Reference}_{name}_{pcb_id}")
                                                    # Go through changes ["property", *new_value*]
                                                    for change in changes:
                                                        prop, value = change[0], change[1]
                                                        # Find geometry in sketch with same Tag
                                                        for index, geom in enumerate(sketch.Geometry):
                                                            if geom.Tag == pad_obj.Tag:
                                                                # Get footprint position
                                                                base = fp_part.Placement.Base
                                                                if prop == "pos_delta":
                                                                    # Get delta from feature object
                                                                    delta = App.Vector(value[0] / SCALE,
                                                                                       -value[1] / SCALE,
                                                                                       0)
                                                                    # Move pad for fp bas and new delta
                                                                    sketch.movePoint(index, 3, base + delta)
                                                                    # Save new delta to pad object
                                                                    pad_obj.PosDelta = delta
                                                                    # Update dictionary
                                                                    for pad in fp["pads_pth"]:
                                                                        if pad["pad_name"] == name:
                                                                            pad.update({"pos_delta": [
                                                                                value[0],
                                                                                value[1]
                                                                            ]})

                                                                elif prop == "hole_size":
                                                                    # todo UNITS
                                                                    # Change radius constraint to new value
                                                                    sketch.setDatum(pad_obj.Constraint,
                                                                                    App.Units.Quantity(
                                                                                        f"{value[0]/SCALE} mm"
                                                                                        )
                                                                                    )
                                                                    # Save new value to pad object
                                                                    pad_obj.Radius = value[0]/SCALE
                                                                    # Update dictionary
                                                                    for pad in fp["pads_pth"]:
                                                                        if pad["pad_name"] == name:
                                                                            pad.update({"hole_size": [
                                                                                value[0],
                                                                                value[1]
                                                                            ]})

                                        elif prop == "3d_models":
                                            # Remove all step models from FP container
                                            for feature in fp_part.Group:
                                                if "Pads" in feature.Label:
                                                    continue
                                                doc.removeObject(feature.Name)

                                            # Re-import footprint step models to FP container
                                            for model in value:
                                                importModel(model, fp, fp_part, doc, pcb, MODELS_PATH)

    # TODO add PCB as Property of pcb_Part


class CADSyncHost(QtGui.QDockWidget):

    def __init__(self):
        super().__init__()

        self.HOST = 'localhost'
        self.STARTING_PORT = 5050
        self.MAX_PORT_RANGE = 20
        self.port = self.STARTING_PORT
        self.HEADER = 8
        self.FORMAT = 'utf-8'

        self.pcb = None
        self.diff = None

        self.initUI()
        threading.Thread(target=self.startServer).start()

    def initUI(self):
        self.setObjectName("CAD Sync Host")
        self.resize(QtCore.QSize(300, 100).expandedTo(self.minimumSizeHint()))  # sets size of the widget

        # Text
        self.text_connection = QtGui.QLabel("", self)
        self.text_connection.move(30, 25)
        self.text_connection.resize(180, 25)
        self.text_connection.hide()

        self.text_controls = QtGui.QLabel("Object controls:", self)
        self.text_controls.move(10, 90)

        # Buttons
        self.button_start_server = QtGui.QPushButton("Accept new connection", self)
        self.button_start_server.clicked.connect(self.onButtonStartServer)
        self.button_start_server.move(25, 25)
        self.button_start_server.resize(180, 25)

        self.button_stop_server = QtGui.QPushButton("Stop listening", self)
        self.button_stop_server.clicked.connect(self.onButtonStopServer)
        self.button_stop_server.hide()
        self.button_stop_server.move(25, 25)
        self.button_stop_server.resize(180, 25)
        self.button_stop_server.setEnabled(False)

        # self.button_test = QtGui.QPushButton("Test", self)
        # self.button_test.clicked.connect(self.onButtonTest)
        # self.button_test.move(120, 120)
        # #self.button_test.setEnabled(False)

        self.button_draw_pcb = QtGui.QPushButton("Draw pcb", self)
        self.button_draw_pcb.clicked.connect(self.onButtonDraw)
        self.button_draw_pcb.move(10, 120)
        self.button_draw_pcb.setEnabled(False)

        self.button_apply_diff = QtGui.QPushButton("Apply diff", self)
        self.button_apply_diff.clicked.connect(self.onButtonApplyDiff)
        self.button_apply_diff.move(120, 120)
        self.button_apply_diff.setEnabled(False)

        self.button_scan_pcb = QtGui.QPushButton("Update JSON", self)
        self.button_scan_pcb.clicked.connect(self.onButtonScan)
        self.button_scan_pcb.move(10, 170)
        self.button_scan_pcb.setEnabled(False)

        self.button_send_message = QtGui.QPushButton("Send JSON", self)
        self.button_send_message.clicked.connect(self.onButtonSend)
        self.button_send_message.move(120, 170)
        self.button_send_message.setEnabled(False)

        self.button_get_diff = QtGui.QPushButton("Get diff", self)
        self.button_get_diff.clicked.connect(self.onButtonGetDiff)
        self.button_get_diff.move(10, 220)
        self.button_get_diff.setEnabled(False)

    # --------------------------------- Button Methods --------------------------------- #
    def onButtonStartServer(self):
        # Start server in another thread
        threading.Thread(target=self.startServer).start()

    def onButtonStopServer(self):
        self.closeSocket()

    def onButtonTest(self):
        pass

    def onButtonDraw(self):
        drawPcb(doc=App.activeDocument(),
                doc_gui=Gui.ActiveDocument,
                pcb=self.pcb)

    def onButtonScan(self):
        try:
            pcb_updated = scanPcb(doc=App.activeDocument(),
                                  pcb=self.pcb)

            self.pcb = pcb_updated

        except Exception as e:
            print(e)

    def onButtonSend(self):
        if self.pcb:
            print("Sending message")
            self.sendMessage(json.dumps("I, FC, am sending this message"))

    def onButtonLoadPcbPart(self):
        if Gui.Selection.getSelection():
            self.pcb_part = Gui.Selection.getSelection()[0]
            print(f"{self.pcb_part.Label} added to widget")

            self.pcb = self.pcb_part.JSON

    def onButtonGetDiff(self):
        pass

    def onButtonApplyDiff(self):
        if self.pcb and self.diff:
            updatePartFromDiff(App.activeDocument(), self.pcb, self.diff)

            App.activeDocument().recompute()
            # updateDict(self.pcb, self.diff)
            # todo update dictionary
            self.diff = None

    # --------------------------------- Socket--------------------------------- #
    def closeSocket(self):
        print("Closing connection manually")
        self.socket.close()
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

    def startServer(self):
        # Bug:  if socket 5050 remains from last session and new session
        #       is on 5051, client connects to old socket 5050.
        self.button_stop_server.setEnabled(True)
        self.button_stop_server.show()
        self.button_start_server.setEnabled(False)
        self.button_start_server.hide()
        print("[SERVER] Server starting...")
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # Loop through available sockets
        socket_searching = True
        while socket_searching:
            if self.port > (self.STARTING_PORT+self.MAX_PORT_RANGE):
                socket_searching = False
                self.port = 5050
                print(f"Failed to start server, port reset to: {self.port}")

            try:
                self.socket.bind((self.HOST, self.port))
                socket_searching = False
                # Wait for connection
                self.socket.listen()
                print(f"[LISTENING] Server is listening on {self.HOST}, port {self.port}")

                while True:
                    # Accept new connection
                    self.conn, self.addr = self.socket.accept()
                    # Start handleClient method in new thread for each connection
                    threading.Thread(target=self.handleClient).start()
                    print("Client connected, closing socket")
                    self.socket.close()

                    self.button_start_server.setEnabled(False)
                    self.button_start_server.hide()
                    self.button_stop_server.setEnabled(False)
                    self.button_stop_server.hide()
                    break

            except OSError as e:
                # BUG: error message when manually closing socket.
                # FIX: Catch error number 10038 (on windows: Operation was attempted on
                #                                            something that is not a socket)
                if e.errno == 10038:
                    pass
                # Only one usage of each socket address is permitted
                elif e.errno == 10048:
                    self.port = self.port + 1
                else:
                    print(e)

    def handleClient(self):
        """
        Worker thread for receiving messages from client
        """
        self.text_connection.setText(f"Connected to {self.addr}")
        self.text_connection.show()

        self.connected = True
        while self.connected:
            # Receive first message
            first_msg = self.conn.recv(self.HEADER).decode(self.FORMAT)
            # Check if anything was actually sent
            if first_msg:
                msg_type = first_msg.split('_')[0]
                msg_length = first_msg.split('_')[1]
                # Receive second message
                msg_length = int(msg_length)
                data_raw = self.conn.recv(msg_length).decode(self.FORMAT)
                data = json.loads(data_raw)

                # Check for disconnect message
                if msg_type == "!DIS":
                    self.connected = False

                elif msg_type == "PCB":
                    # Check for dictionary type
                    if type(data) is dict:
                        # Received valid pcb dictionary
                        if not self.pcb:
                            self.pcb = data
                            self.button_draw_pcb.setEnabled(True)

                elif msg_type == "DIF":
                    # Check if not null
                    if data and type(data) is dict:
                        # Received diff dictionary
                        self.diff = data
                        self.button_apply_diff.setEnabled(True)

                print(f"[DATA] Message received from client:\n{data}")

        print("[SERVER] Client disconnected, connection closed")
        self.conn.close()
        self.text_connection.hide()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

        self.button_send_message.setEnabled(False)
        self.button_apply_diff.setEnabled(False)
        # self.button_draw_pcb.setEnabled(False)
        # self.button_scan_pcb.setEnabled(False)
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()

    def sendMessage(self, msg):
        # Calculate length of first message
        msg_length = len(msg)
        send_length = str(msg_length).encode(self.FORMAT)
        # Pad first message
        send_length += b' ' * (self.HEADER - len(send_length))
        # Send length end object
        self.conn.send(send_length)
        self.conn.send(msg.encode(self.FORMAT))


# ------------------------------ Code -------------------------------------------


app = QtGui.QApplication
main_window = Gui.getMainWindow()
# Create widget
myDockWidget = CADSyncHost()
# Add the widget to the main window
main_window.addDockWidget(QtCore.Qt.RightDockWidgetArea, myDockWidget)