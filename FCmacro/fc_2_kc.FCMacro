import FreeCAD as App
import FreeCADGui as Gui

import configparser
import hashlib
import json
import logging
import logging.config
import os
import sys

from PySide import QtGui, QtCore

from API_scripts.part_scanner import FcPcbScanner
from API_scripts.part_drawer import FcPcbDrawer
from API_scripts.part_updater import FcPartUpdater
from Config.config_loader import ConfigLoader
from Socket.server import Server, ConnectionHandler


# Get the path to log file because configparsed doesn't search for the file in same directory where module is saved
# in file system. (it searches in directory where script is executed)
directory_path = os.path.dirname(os.path.realpath(__file__))
# Backslash is replaced with forwardslash, otherwise the file paths don't work
logging_config_file = os.path.join(directory_path, "Config", "logging.ini").replace("\\", "/")
# Define directory path for /Logs
log_files_directory = os.path.join(directory_path, "Logs").replace("\\", "/")
# Configure logging module with .ini file, pass /Logs directory as argument (part of formatted string in .ini)
logging.config.fileConfig(logging_config_file, defaults={"log_directory": log_files_directory})

# Initialize logger and log basic system info:
logger = logging.getLogger()
logger.info("Plugin executed on: " + repr(sys.platform))
logger.info("Plugin executed with python version: " + repr(sys.version))
logger.info("FreeCAD build version: " + str(App.Version()))


class GenSignal:
    def __init__(self,typ=None):
        Emitter = type("Emitter", (QtCore.QObject,), {"signal": QtCore.Signal(typ)})
        self.emitter = Emitter()

    def emit(self,*args,**kw):
        self.emitter.signal.emit(*args,**kw)

    def connect(self,  slot):
        self.emitter.signal.connect(slot)

#class FreeCadHost(QtGui.QDockWidget, QtCore.QObject):
class FreeCadHost(QtGui.QDockWidget):

    # # QT signal for stopping server in worker thread
    # stop_server_signal = QtCore.Signal()

    def __init__(self):
        super().__init__()
        # TODO problem with inheriting from two classes
        # QtGui.QDockWidget.__init__(self)
        # QtCore.QObject.__init__(self)
        self.stop_server_signal = GenSignal(int)

        # Get FreeCAD document and GUI objects
        self.doc = App.activeDocument()
        self.doc_gui = Gui.ActiveDocument

        # Initialize dictionary variables
        self.pcb = {}
        self.diff = {}

        # Get config.ini file path
        config_file = os.path.join(directory_path, "Config", "config.ini").replace("\\", "/")
        # Load config data
        self.config = ConfigLoader(config_file)
        logger.info(f"Loaded configuration: {self.config.getConfig()}")

        # Set up the User Interface
        self.setupUi()

    def setupUi(self):
        self.setObjectName("FreeCAD Host")
        self.resize(QtCore.QSize(300, 100).expandedTo(self.minimumSizeHint()))  # sets size of the widget

        # Text
        self.text_connection = QtGui.QLabel("", self)
        self.text_connection.move(30, 25)
        self.text_connection.resize(180, 25)
        self.text_connection.hide()

        self.text_controls = QtGui.QLabel("Object controls:", self)
        self.text_controls.move(10, 90)

        # Buttons
        self.button_start_server = QtGui.QPushButton("Accept new connection", self)
        self.button_start_server.clicked.connect(self.onButtonStartServer)
        self.button_start_server.move(25, 25)
        self.button_start_server.resize(180, 25)

        self.button_stop_server = QtGui.QPushButton("Stop listening", self)
        self.button_stop_server.clicked.connect(self.onButtonStopServer)
        self.button_stop_server.hide()
        self.button_stop_server.move(25, 25)
        self.button_stop_server.resize(180, 25)
        self.button_stop_server.setEnabled(False)

        self.button_draw_pcb = QtGui.QPushButton("Draw pcb", self)
        self.button_draw_pcb.clicked.connect(self.onButtonDraw)
        self.button_draw_pcb.move(10, 120)
        self.button_draw_pcb.setEnabled(False)

        self.button_apply_diff = QtGui.QPushButton("Apply diff", self)
        self.button_apply_diff.clicked.connect(self.onButtonApplyDiff)
        self.button_apply_diff.move(120, 120)
        self.button_apply_diff.setEnabled(False)

        self.button_scan_board = QtGui.QPushButton("Scan PCB", self)
        self.button_scan_board.clicked.connect(self.onButtonScanBoard)
        self.button_scan_board.move(10, 180)
        self.button_scan_board.setEnabled(False)

        self.button_send_message = QtGui.QPushButton("Send Diff", self)
        self.button_send_message.clicked.connect(self.onButtonSendMessage)
        self.button_send_message.move(120, 180)
        # TODO handle button enable/disable
        self.button_send_message.setEnabled(True)

    # --------------------------------- Hude/Show Buttons --------------------------------- #

    def connectedButtons(self):
        self.text_connection.setText(f"Connected")
        self.text_connection.show()
        self.button_stop_server.hide()
        self.button_start_server.hide()

    def disconnectedButtons(self):
        self.text_connection.hide()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

        self.button_apply_diff.setEnabled(False)
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()

    def serverClosedButtons(self):
        # Disable stop and enable start when server is stopped
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

    def serverStartButtons(self):
        # Enable stop button and disable start when starting server
        self.button_start_server.setEnabled(False)
        self.button_start_server.hide()
        self.button_stop_server.setEnabled(True)
        self.button_stop_server.show()

    # --------------------------------- Button Methods --------------------------------- #
    def onButtonStartServer(self):
        self.startServer()

    def onButtonStopServer(self):
        logger.debug(f"Calling server.stop method")
        self.server.stop()
        # Set appropriate button visibility
        self.serverClosedButtons()

    def onButtonDraw(self):
        pass

    def onButtonApplyDiff(self):
        if self.pcb and self.diff:
            updatePartFromDiff(self.doc, self.pcb, self.diff)

            self.doc.recompute()
            self.diff = None

    def onButtonScanBoard(self):
        self.startPartScanner()

    def onButtonSendMessage(self):
        if self.diff:
            self.sendMessage(json.dumps(self.diff), msg_type="DIF")


    # --------------------------------- QThreads --------------------------------- #
    def startServer(self):
        self.server_thread = QtCore.QThread()
        self.server = Server(self.config)
        self.server.moveToThread(self.server_thread)

        # Connect signals and slots
        self.server_thread.started.connect(self.server.run)
        self.server.finished.connect(self.server_thread.quit)
        self.server.finished.connect(self.server.deleteLater)
        self.server_thread.finished.connect(self.server_thread.deleteLater)
        # Connect finished signal to startConnection method - this passes socket.socket object to ConnectionHandler
        self.server.finished.connect(self.startConnection)

        # Start the thread
        self.server_thread.start()
        # Enable stop button and disable start when starting server
        self.serverStartButtons()

    def startConnection(self, server_response):
        # Get data from dictionary type
        status = server_response.get("status")

        # Perform check if connection is real or fake (quasy-abort) see Server class doctring
        if status == "abort":
            logger.debug("Server aborted, ignoring connection socket")
            # Show correct button configuration - server was aborted, enable button for starting server again
            self.serverClosedButtons()

        elif status == "exception":
            logger.error(f"Exception when starting server")

        elif status == "client_connected":
            # Change button visibility
            self.connectedButtons()
            logger.debug("Client connected, launching connection handler")

            # Get data from dictionary type
            connection_socket = server_response.get("connection_socket")
            # Attach connection handle (socket) to class, so that a message can be sent manually by button (sendMessage)
            self.socket = connection_socket

            # Start Handler in new thread
            self.client_thread = QtCore.QThread()
            # Instatiate Connection class with client connection Socket
            self.connection = ConnectionHandler(connection_socket, self.config)
            self.connection.moveToThread(self.client_thread)

            # Connecting signals
            self.client_thread.started.connect(self.connection.run)
            self.connection.finished.connect(self.client_thread.quit)
            self.connection.finished.connect(self.connection.deleteLater)
            self.connection.finished.connect(self.onConnectionHandlerFinished)
            self.client_thread.finished.connect(self.client_thread.deleteLater)
            # Set and draw PCB signals
            self.connection.received_pcb.connect(self.setPcb)
            self.connection.received_pcb.connect(self.startPcbDrawer)
            # Apply Diff signal
            self.connection.received_diff.connect(self.startPartUpdater)
            # Hash received signal
            self.connection.received_hash.connect(self.onReceivedHash)

            # Start handle client thread
            self.client_thread.start()

            # # Reset buttons
            # self.connectedButtons()
            # self.connection.finished.connect(
            #     lambda: self.disconnectedButtons()
            # )

    def onConnectionHandlerFinished(self):
        # Changed button visibility
        self.disconnectedButtons()

    @staticmethod
    def logConnectionStatus(status):
        # logger.info(f"[CONNECTION] {status}")
        # This is being logged in "server" logger
        pass

    def onReceivedHash(self, received_pcb_hash):
        """
        Compare received hash to own hash, if same clear local diff
        :param received_pcb_hash: str
        :return:
        """
        logger.debug(f"Received hash: {received_pcb_hash}")
        own_pcb_hash = hashlib.md5(str(self.pcb).encode("utf-8")).hexdigest()
        logger.debug(f"Own hash: {own_pcb_hash}")

        # Dump data model for debugging
        FreeCadHost.dumpToJsonFile(self.pcb, "/Logs/data_indent.json")

        if received_pcb_hash == own_pcb_hash:
            logger.info(f"Hash match, diff synced")
            logger.info(f"Clearing local diff: {self.diff}")
            self.diff = {}
        else:
            logger.error(f"Hash mismatch, sync lost!")


    def startPcbDrawer(self):
        self.pcb_drawer_thread = QtCore.QThread()
        self.pcb_drawer = FcPcbDrawer(doc=self.doc,
                                      doc_gui=self.doc_gui,
                                      pcb=self.pcb,
                                      models_path=self.config.models_path)
        self.pcb_drawer.moveToThread(self.pcb_drawer_thread)
        # Signals
        # Connect start signal to run() method
        self.pcb_drawer_thread.started.connect(self.pcb_drawer.run)
        # Finished signal
        self.pcb_drawer.finished.connect(self.sendHashOfDataModel)
        self.pcb_drawer.finished.connect(self.pcb_drawer_thread.quit)
        self.pcb_drawer.finished.connect(self.pcb_drawer.deleteLater)
        self.pcb_drawer_thread.finished.connect(self.pcb_drawer_thread.deleteLater)
        # Log signal
        self.pcb_drawer.progress.connect(self.logDrawerProgress)
        # Start thread
        self.pcb_drawer_thread.start()

    @staticmethod
    def logDrawerProgress(status):
        # This function exist because when logging in pcb_drawer module FC crashed. Log is passed by signal and logged
        # here:
        logger.debug(f"[DRAWER] {status}")

    def startPartUpdater(self, diff):
        self.update_thread = QtCore.QThread()
        self.update_obj = FcPartUpdater(doc=self.doc,
                                        pcb=self.pcb,
                                        diff=diff)
        self.update_obj.moveToThread(self.update_thread)
        # Connecting signals
        # Connect start signal to run() method
        self.update_thread.started.connect(self.update_obj.run)
        # Finished signal
        self.update_obj.finished.connect(self.finishedPartUpdater)
        self.update_obj.finished.connect(self.update_thread.quit)
        self.update_obj.finished.connect(self.update_obj.deleteLater)
        self.update_thread.finished.connect(self.update_thread.deleteLater)
        # Connect finished signal to setter function for setting new pcb dict
        self.update_obj.finished.connect(self.setPcb)
        # Start apply diff thread
        self.update_thread.start()

    def finishedPartUpdater(self):
        # First send hash of updated pcb dictionary, then clear local diff -> we assume all changes were applied in
        # Updater script
        self.sendHashOfDataModel()
        logger.info(f"Clearing local Diff: {self.diff}")
        self.diff = {}

    def sendHashOfDataModel(self):
        """ Call this function after updating part so KiCAD can confirm change """
        # Convert pcb dictionary to encoded string, hash string, convert hash object to string
        pcb_hash = hashlib.md5(str(self.pcb).encode("utf-8")).hexdigest()

        logger.info("Sending hash")
        # Send this hash as message to KC
        self.sendMessage(json.dumps(pcb_hash), msg_type="HASH")

    def startPartScanner(self):
        self.scanner_thread = QtCore.QThread()
        self.scanner_obj = FcPcbScanner(doc=self.doc,
                                        pcb=self.pcb,
                                        diff=self.diff)
        self.scanner_obj.moveToThread(self.scanner_thread)

        # Connecting signals
        # Connect start signal to run() method
        self.scanner_thread.started.connect(self.scanner_obj.run)
        # Finished signal
        self.scanner_obj.finished.connect(self.finishedPcbScanner)
        self.scanner_obj.finished.connect(self.scanner_thread.quit)
        self.scanner_obj.finished.connect(self.scanner_obj.deleteLater)
        self.scanner_thread.finished.connect(self.scanner_thread.deleteLater)

        # Start thread
        logger.info(f"Calling scanner")
        self.scanner_thread.start()

    def finishedPcbScanner(self, diff):
        logger.debug(f"finishedPcbScanner, returns: {diff}")
        self.diff = diff
        logger.info(f"Diff: {self.diff}")
        FreeCadHost.dumpToJsonFile(self.diff, "/Logs/diff.json")
        FreeCadHost.dumpToJsonFile(self.pcb, "/Logs/data_indent.json")
        self.refreshDocument()

    # ---------------------------------------------------------------------------------

    def setPcb(self, data):
        self.pcb = data
        logger.debug(f"[HOST] PCB Dictionary set: {self.pcb}")
        self.button_draw_pcb.setEnabled(True)
        self.button_scan_board.setEnabled(True)

    def sendMessage(self, msg, msg_type="!DIS"):
        logger.debug(f"Sending message {msg_type}_{msg}")
        # Calculate length of first message
        msg_length = len(msg)
        send_length = str(msg_length)
        # First message is type and length of second message
        first_message = f"{msg_type}_{send_length}".encode(self.config.format)
        # Pad first message
        first_message += b' ' * (self.config.header - len(first_message))
        # Send length and object
        self.socket.send(first_message)
        self.socket.send(msg.encode(self.config.format))

    def refreshDocument(self):
        logger.info(f"Recomputing document")
        self.doc.recompute()

    @staticmethod
    def dumpToJsonFile(data, filename):
        with open(directory_path + filename, "w") as f:
            json.dump(data, f, indent=4)


# Instantiate host plugin
host_plugin = FreeCadHost()
# Add the widget to the main window right area
Gui.getMainWindow().addDockWidget(QtCore.Qt.RightDockWidgetArea, host_plugin)