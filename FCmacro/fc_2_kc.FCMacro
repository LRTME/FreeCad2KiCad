import FreeCAD as App
import FreeCADGui as Gui

import json
import logging
import os
import sys

from PySide import QtGui, QtCore

from freecad_functions import scanFootprints
from scripts.board_drawer import PcbDrawer
from scripts.part_updater import PartUpdater
from Socket.server import Server, ConnectionHandler


# Set up logger
logger = logging.getLogger(__name__)
# Get plugin directory and add /Logs folder
dir_path = os.path.dirname(os.path.realpath(__file__))
if not os.path.exists(dir_path + "/Logs"):
    os.makedirs(dir_path + "/Logs")
handler = logging.FileHandler(filename=dir_path + "/Logs/freecad_host.log", mode="w")
formatter = logging.Formatter(fmt="%(asctime)s - %(name)s - %(levelname)s - %(message)s", datefmt="%d/%m/%Y %H:%M:%S")
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.setLevel(logging.DEBUG)

# Load configuration file
config_data = json.load(open(file=dir_path + "/config.json", encoding="utf-8"))


class FreeCadHost(QtGui.QDockWidget, QtCore.QObject):

    # QT signal for stopping server in worker thread
    stop_server_signal = QtCore.Signal()

    def __init__(self):
        super().__init__()
        self.doc = App.activeDocument()
        self.doc_gui = Gui.ActiveDocument
        self.pcb = None
        self.diff = None

        self.setupUi()

    def setupUi(self):
        self.setObjectName("FreeCAD Host")
        self.resize(QtCore.QSize(300, 100).expandedTo(self.minimumSizeHint()))  # sets size of the widget

        # Text
        self.text_connection = QtGui.QLabel("", self)
        self.text_connection.move(30, 25)
        self.text_connection.resize(180, 25)
        self.text_connection.hide()

        self.text_controls = QtGui.QLabel("Object controls:", self)
        self.text_controls.move(10, 90)

        # Buttons
        self.button_start_server = QtGui.QPushButton("Accept new connection", self)
        self.button_start_server.clicked.connect(self.onButtonStartServer)
        self.button_start_server.move(25, 25)
        self.button_start_server.resize(180, 25)

        self.button_stop_server = QtGui.QPushButton("Stop listening", self)
        self.button_stop_server.clicked.connect(self.onButtonStopServer)
        self.button_stop_server.hide()
        self.button_stop_server.move(25, 25)
        self.button_stop_server.resize(180, 25)
        self.button_stop_server.setEnabled(False)

        self.button_draw_pcb = QtGui.QPushButton("Draw pcb", self)
        self.button_draw_pcb.clicked.connect(self.onButtonDraw)
        self.button_draw_pcb.move(10, 120)
        self.button_draw_pcb.setEnabled(False)

        self.button_apply_diff = QtGui.QPushButton("Apply diff", self)
        self.button_apply_diff.clicked.connect(self.onButtonApplyDiff)
        self.button_apply_diff.move(120, 120)
        self.button_apply_diff.setEnabled(False)

        self.button_scan_board = QtGui.QPushButton("Scan PCB", self)
        self.button_scan_board.clicked.connect(self.onButtonScanBoard)
        self.button_scan_board.move(10, 180)
        self.button_scan_board.setEnabled(False)

    # ---------------------------------------------------------------------------

    def connectedButtons(self):
        self.text_connection.setText(f"Connected")
        self.text_connection.show()

    def disconnectedButtons(self):
        self.text_connection.hide()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

        self.button_apply_diff.setEnabled(False)
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()

    def serverClosedButtons(self):
        # Disable stop and enable start when server is stopped
        self.button_start_server.setEnabled(False)
        self.button_start_server.hide()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

    def serverStartButtons(self):
        # Enable stop button and disable start when starting server
        self.button_stop_server.setEnabled(True)
        self.button_stop_server.show()
        self.button_start_server.setEnabled(False)
        self.button_start_server.hide()

    # --------------------------------- Button Methods --------------------------------- #
    def onButtonStartServer(self):
        self.startServerThread()

    def onButtonStopServer(self):
        # logger.debug("Emmiting manual stop signal")
        # print("Emmiting manual stop signal")
        # self.stop_server_signal.emit()

        self.button_start_server.setEnabled(True)
        self.button_start_server.show()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

    def onButtonDraw(self):
        pass

    def onButtonApplyDiff(self):
        if self.pcb and self.diff:
            updatePartFromDiff(self.doc, self.pcb, self.diff)

            self.doc.recompute()
            self.diff = None

    def onButtonScanBoard(self):
        scanFootprints(doc=self.doc,
                       pcb=self.pcb)
        self.doc.recompute()

    # --------------------------------- QThreads --------------------------------- #
    def startServerThread(self):
        self.server_thread = QtCore.QThread()
        self.server = Server(config_data["host"], config_data["port"])
        self.server.moveToThread(self.server_thread)

        # Connect signals and slots
        self.server_thread.started.connect(self.server.run)
        self.server.finished.connect(self.server_thread.quit)
        self.server.finished.connect(self.server.deleteLater)
        self.server_thread.finished.connect(self.server_thread.deleteLater)
        # "connected" signal passes Socket.Socket class to startClientThread method for instantiating Connection
        self.server.connected.connect(self.startClientThread)
        self.server.progress.connect(self.logServerStatus)
        # Connect a signal to worker slot for communicating back to worker thread (stop server)
        self.stop_server_signal.connect(self.server.workerSlot)

        # Start the thread
        self.server_thread.start()

        # Final resets
        # Enable stop button and disable start when starting server
        self.serverStartButtons()
        # Disable stop end enable start when server is stopped
        self.server_thread.finished.connect(
            lambda: self.serverClosedButtons()
        )

    def logServerStatus(self, status):
        logger.info(f"[SERVER] {status}")
        print(f"[SERVER] {status}")


    def startClientThread(self, connection_socket):
        self.client_thread = QtCore.QThread()
        # Instatiate Connection class with client connection Socket
        self.connection = ConnectionHandler(connection_socket, config_data["header"], config_data["format"])
        self.connection.moveToThread(self.client_thread)

        # Connecting signals
        self.client_thread.started.connect(self.connection.run)
        self.connection.finished.connect(self.client_thread.quit)
        self.connection.finished.connect(self.connection.deleteLater)
        self.client_thread.finished.connect(self.client_thread.deleteLater)
        self.connection.progress.connect(self.logConnectionStatus)
        # Set and draw PCB signals
        self.connection.received_pcb.connect(self.setPcb)
        self.connection.received_pcb.connect(self.startPcbDrawerThread)
        # Apply Diff signal
        self.connection.received_diff.connect(self.startPartUpdaterThread)

        # Start handle client thread
        self.client_thread.start()

        # Reset
        self.connectedButtons()
        self.connection.finished.connect(
            lambda: self.disconnectedButtons()
        )

    def logConnectionStatus(self, status):
        logger.info(f"[CONNECTION] {status}")
        print(f"[CONNECTION] {status}")

    def startPcbDrawerThread(self, pcb):
        self.pcb_drawer_thread = QtCore.QThread()
        self.pcb_drawer = PcbDrawer(doc=self.doc,
                                    doc_gui=self.doc_gui,
                                    pcb=pcb,
                                    models_path=config_data["models_path"])
        self.pcb_drawer.moveToThread(self.pcb_drawer_thread)
        # Signals
        self.pcb_drawer_thread.started.connect(self.pcb_drawer.run)
        self.pcb_drawer.finished.connect(self.pcb_drawer_thread.quit)
        self.pcb_drawer.finished.connect(self.pcb_drawer.deleteLater)
        self.pcb_drawer_thread.finished.connect(self.pcb_drawer_thread.deleteLater)
        self.pcb_drawer.progress.connect(self.logDrawerProgress)
        # Start thread
        self.pcb_drawer_thread.start()

    def logDrawerProgress(self, status):
        logger.debug(f"[DRAWER] {status}")

    # def guiViewFit(self):
    #     Gui.SendMsgToActiveView("ViewFit")

    def startPartUpdaterThread(self, diff):
        self.update_thread = QtCore.QThread()
        self.update_obj = PartUpdater(doc=App.activeDocument(),
                                      pcb=self.pcb,
                                      diff=diff)
        self.update_obj.moveToThread(self.update_thread)
        # Connecting signals
        self.update_thread.started.connect(self.update_obj.run)
        self.update_obj.finished.connect(self.update_thread.quit)
        self.update_obj.finished.connect(self.update_obj.deleteLater)
        self.update_thread.finished.connect(self.update_thread.deleteLater)
        self.update_obj.progress.connect(self.logUpdaterProgress)
        # Connect finished signal to setter function for setting new pcb dict
        self.update_obj.finished.connect(self.setPcb)
        # Start apply diff thread
        self.update_thread.start()

    def logUpdaterProgress(self, status):
        logger.debug(f"[UPDATER] {status}")

    # ---------------------------------------------------------------------------------

    def setPcb(self, data):
        self.pcb = data
        logger.debug(f"[HOST] PCB Dictionary set: {self.pcb}")
        self.button_draw_pcb.setEnabled(True)
        self.button_scan_board.setEnabled(True)

    #
    # def closeSocket(self):
    #     print("Closing connection manually")
    #     self.Socket.close()
    #
    #     self.button_start_server.setEnabled(True)
    #     self.button_start_server.show()
    #     self.button_stop_server.setEnabled(False)
    #     self.button_stop_server.hide()


    def sendMessage(self, msg):
        # Calculate length of first message
        msg_length = len(msg)
        send_length = str(msg_length).encode(config_data["format"])
        # Pad first message
        send_length += b' ' * (config_data["header"] - len(send_length))
        # Send length end object
        self.conn.send(send_length)
        self.conn.send(msg.encode(config_data["format"]))


# Instantiate host plugin
host_plugin = FreeCadHost()
# Add the widget to the main window right area
Gui.getMainWindow().addDockWidget(QtCore.Qt.RightDockWidgetArea, host_plugin)