"""
    Instantiates main plugin class and adds it as a widget to main window.
    All functionality is handled by FreeCadServer class.
"""

import FreeCAD as App
import FreeCADGui as Gui

import hashlib
import json
import logging
import logging.config
import os
import sys

from PySide import QtGui, QtCore

# Add plugin directory to path for imports to work
directory_path = os.path.dirname(os.path.realpath(__file__))
sys.path.append(directory_path)

from API_scripts.part_scanner import FcPcbScanner
from API_scripts.part_drawer import FcPartDrawer
from API_scripts.part_updater import FcPartUpdater
from Config.config_loader import ConfigLoader
from Socket.server import Server, ConnectionHandler

# Get the path to log file because configparser doesn't search for the file in same directory where module is saved
# in file system. (it searches in directory where script is executed)
# Backslash is replaced with forward slash, otherwise the file paths don't work
logging_config_file = os.path.join(directory_path, "Config", "logging.ini").replace("\\", "/")
# Create Logs directory if it doesn't exist
if not os.path.exists(os.path.join(directory_path, "Logs")):
    os.makedirs(os.path.join(directory_path, "Logs"))
# Define directory path for /Logs
log_files_directory = os.path.join(directory_path, "Logs").replace("\\", "/")
# Configure logging module with .ini file, pass /Logs directory as argument (part of formatted string in .ini)
logging.config.fileConfig(logging_config_file, defaults={"log_directory": log_files_directory})

# Initialize logger and log basic system info:
logger = logging.getLogger()
logger.info("Plugin executed on: " + repr(sys.platform))
logger.info("Plugin executed with python version: " + repr(sys.version))
logger.info("FreeCAD build version: " + str(App.Version()))

# Button placement magic numbers
FIRST_COLUMN_X = 10
SECOND_COLUMN_X = 120
INITIAL_Y = 120
OFFSET_Y = 60


class FreeCadServer(QtGui.QDockWidget):
    """ Main plugin class. """

    def __init__(self):
        super().__init__()

        # Get FreeCAD document and GUI objects
        self.doc = App.activeDocument()
        self.doc_gui = Gui.ActiveDocument

        self.pcb = {}
        self.diff = {}
        self.existing_placement = None

        # Get config.ini file path
        config_file = os.path.join(directory_path, "Config", "config.ini").replace("\\", "/")
        # Load config data
        self.config = ConfigLoader(config_file)
        logger.info(f"Loaded configuration: {self.config.getConfig()}")

        # Set up the User Interface
        self.setupUi()

    def setupUi(self):
        """ Set up buttons and text. """
        self.setObjectName("FreeCAD Host")
        self.resize(QtCore.QSize(300, 100).expandedTo(self.minimumSizeHint()))  # sets size of the widget

        # Text
        self.text_connection = QtGui.QLabel("", self)
        self.text_connection.move(30, 25)
        self.text_connection.resize(180, 25)
        self.text_connection.hide()

        self.text_controls = QtGui.QLabel("Object controls:", self)
        self.text_controls.move(10, 90)

        # Buttons
        self.button_start_server = QtGui.QPushButton("Accept new connection", self)
        self.button_start_server.clicked.connect(self.onButtonStartServer)
        self.button_start_server.move(25, 25)
        self.button_start_server.resize(180, 25)

        self.button_stop_server = QtGui.QPushButton("Stop listening", self)
        self.button_stop_server.clicked.connect(self.onButtonStopServer)
        self.button_stop_server.hide()
        self.button_stop_server.move(25, 25)
        self.button_stop_server.resize(180, 25)
        self.button_stop_server.setEnabled(False)

        self.button_sync = QtGui.QPushButton("Sync", self)
        self.button_sync.clicked.connect(self.onButtonSync)
        self.button_sync.move(FIRST_COLUMN_X, INITIAL_Y)
        self.button_sync.setEnabled(False)

    # --------------------------------- Button Methods --------------------------------- #
    def onButtonStartServer(self):
        """ Call method on button press. """
        self.startServer()

    def onButtonStopServer(self):
        """ Call stop method (in another thread) to queue abort. """
        self.server.stop()
        # Set appropriate button visibility
        self.serverClosedButtons()

    def onButtonSync(self):
        """ Call method on button press. """
        self.startSyncSequence()

    # --------------------------------- Hide/Show Buttons --------------------------------- #

    def connectedButtons(self):
        """ Change button visibility. """
        self.text_connection.show()
        self.button_stop_server.hide()
        self.button_start_server.hide()

    def disconnectedButtons(self):
        """ Change large button text and visibility. """
        self.text_connection.hide()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()
        # Disable buttons for requesting pcb or attaching pcb
        self.button_sync.setEnabled(False)

    def serverClosedButtons(self):
        """ Disable stop and enable start when server is stopped. """
        self.button_start_server.setEnabled(True)
        self.button_start_server.show()
        self.button_stop_server.setEnabled(False)
        self.button_stop_server.hide()

    def serverStartButtons(self):
        """ Enable stop button and disable start when starting server. """
        self.button_start_server.setEnabled(False)
        self.button_start_server.hide()
        self.button_stop_server.setEnabled(True)
        self.button_stop_server.show()

    # ---------------------------------| Sequential Process Methods |--------------------------------- #

    def startServer(self):
        """ 1. step: Start server in a new thread. Thread is stopped and deleted when connection to client occurs. """
        self.server_thread = QtCore.QThread()
        self.server = Server(self.config)
        self.server.moveToThread(self.server_thread)

        # Connect signals and slots
        self.server_thread.started.connect(self.server.run)
        self.server.finished.connect(self.server_thread.quit)
        self.server.finished.connect(self.server.deleteLater)
        self.server_thread.finished.connect(self.server_thread.deleteLater)
        # Connect finished signal to startConnection method - this passes socket.socket object to ConnectionHandler
        self.server.finished.connect(self.onServerFinished)

        # Start the thread
        self.server_thread.start()
        # Enable stop button and disable start when starting server
        self.serverStartButtons()

    def onServerFinished(self, server_response):
        """ 2. step: Attach socket objects to self. """
        # Get data from dictionary type
        status = server_response.get("status")

        # Perform check if connection is real or fake (quasy-abort) see Server class doctring
        if status == "abort":
            logger.debug("Server aborted, ignoring connection socket")
            # Show correct button configuration - server was aborted, enable button for starting server again
            self.serverClosedButtons()

        elif status == "exception":
            logger.error(f"Exception when starting server")

        elif status == "client_connected":
            # Get data from dictionary type
            connection_socket = server_response.get("connection_socket")
            # Attach connection handle (socket) to class, so that a message can be sent manually by button (sendMessage)
            self.socket = connection_socket
            # Change button visibility
            self.connectedButtons()
            # Change button text
            self.text_connection.setText(f"Connected: {self.socket}")
            logger.debug("Client connected.")
            # Enable Sync button.
            self.button_sync.setEnabled(True)

    def startSyncSequence(self):
        """ 3. step: check if plugin instance has a pcb datamodel attached (skip to step 7). """
        if not self.pcb:
            logger.info(f"Datamodel not attached, requesting Pcb")
            # No datamodel, request pcb from KC
            self.requestPcb()
        else:
            logger.info(f"Datamodel attached, requesting Diff")
            # Plugin instance has datamodel attached, proceed with requesting diff
            self.requestDiff()

    def requestPcb(self):
        """ 4. step: send a request message over socket, listen for reply in a new thread. """
        # Send message to request pcb from KiCAD
        self.sendMessage("blankmessage", msg_type="REQPCB")

        # Run ConnectionHandler in a new thread to listen for replies
        self.connection_thread = QtCore.QThread()
        # Instatiate Connection class with client connection Socket
        self.connection = ConnectionHandler(self.socket, self.config)
        self.connection.moveToThread(self.connection_thread)
        # Finished signal
        self.connection_thread.started.connect(self.connection.run)
        self.connection.finished.connect(self.connection_thread.quit)
        self.connection.finished.connect(self.connection.deleteLater)
        self.connection_thread.finished.connect(self.connection_thread.deleteLater)
        self.connection.finished.connect(self.onConnectionHandlerFinished)
        # Custom signals
        self.connection.received_pcb.connect(self.onReceivedPcb)
        self.connection.received_diff.connect(self.onReceivedDiff)
        self.connection.received_diff_reply.connect(self.onReceivedDiffReply)
        # Start thread
        self.connection_thread.start()

    def onReceivedPcb(self, pcb_data: dict):
        """ 5. step: call function to draw part object when data model is received. """
        # Search FC document if Part object with same KIID as received pcb already exists (in case of opening
        # a project with board already in it)
        existing_part = self.findBoardPartByKIID(doc=self.doc,
                                                 kiid=pcb_data.get("general").get("kiid"))
        if existing_part:
            logger.info(f"Found a board {existing_part.Name} with same ID as in KiCAD")
            # Store placement of existing part
            self.existing_placement = existing_part.Placement
            logger.warning("Removing existing board part")
            # Delete existing part
            self.doc.getObject(existing_part.Name).removeObjectsFromDocument()
            self.doc.removeObject(existing_part.Name)

        # Attach dictionary to object
        self.pcb = pcb_data
        # Change button text to indicate registered pcb datamodel
        self.text_connection.setText(f"Connected: {self.pcb.get('general').get('pcb_name')}")

        # Call drawer in a new thread
        logger.info("Drawing a new board part")
        self.startPartDrawer()

    def onPcbDrawerFinished(self, board_part: App.Part):
        """ 6. step: Called when drawer is finished, enables Sync button. """
        # Move newly drawn part to same placement where old part was (if part was already in document)
        if self.existing_placement:
            logger.warning(f"Moving redrawn board to same position.")
            board_part.Placement = self.existing_placement

        logger.info("Recomputing document")
        self.doc.recompute()
        Gui.SendMsgToActiveView("ViewFit")

    def requestDiff(self):
        """ 7. step: Send request message when user presses SYNC button. """
        # Change button text to indicate registered pcb datamodel
        self.text_connection.setText(f"Connected: {self.pcb.get('general').get('pcb_name')}")
        logger.info("Sending request message.")
        # Send request message
        self.sendMessage("blankmessage", msg_type="REQDIF")

    def onReceivedDiff(self, diff_data: dict):
        """ 8. step: start PartScanner in a seperate thread to get local Diff """
        # Attach received data to object
        self.kc_diff = diff_data
        # Call PartScanner to get local Diff
        self.startPartScanner()

    def onPartScannerFinished(self, local_diff):
        """ 9. step: merge local Diff and received Diff. Prioritise FC drawings and KC footprints if conflicting. """

        logger.info(f"PartScanner finished {local_diff}")
        merged_diff = {}

        # Select which drawings diff to use:
        fc_drawings = local_diff.get("drawings")
        kc_drawings = self.kc_diff.get("drawings")
        # Use FC drawings if FC Diff has drawings
        drawings = fc_drawings if fc_drawings else kc_drawings
        # Can be None if neither FC nor KC have drawings
        if drawings:
            merged_diff.update({"drawings": drawings})

        # Select which footprints diff to use:
        fc_footprints = local_diff.get("footprints")
        kc_footprints = self.kc_diff.get("footprints")
        # Use KC footprints if KC Diff has footprints
        footprints = kc_footprints if kc_footprints else fc_footprints
        # Can be None if neither FC nor KC have footprints
        if footprints:
            merged_diff.update({"footprints": footprints})

        logger.info(f"Diff merged: {merged_diff}")
        self.dumpToJsonFile(merged_diff, "/Logs/diff.json")
        # Attach diff to object
        self.diff = merged_diff
        # Send new diff to KiCAD
        self.sendMessage(json.dumps(merged_diff), msg_type="DIF")

    def onReceivedDiffReply(self, diff_reply, hash_data):
        """
        10. step: apply diff. diff_reply contains merged diff which was sent to FC before and also updated KIID
        if new drawings were added in FC.
        Hash data is hashed KC data model used to check sync on FC side after updating.
        """
        # Attach received values to object
        self.diff = diff_reply
        self.kc_hash = hash_data
        logger.info(f"Received reply: {self.diff},\nHash: {hash_data}")
        self.dumpToJsonFile(self.diff, "/Logs/diff.json")

        if self.diff:
            # Update FC Part objects
            self.startPartUpdater(self.diff)
        else:
            # Go to next step
            self.onPartUpdaterFinished()

    def onPartUpdaterFinished(self):
        """ 11: step: compare hashes of both data models to confirm sync. """
        logger.info(f"Finished part updater, recomputing document")
        self.doc.recompute()
        # Write data model to file for debugging purposes
        self.dumpToJsonFile(self.pcb, "/Logs/data_indent.json")

        pcb_hash = hashlib.md5(str(self.pcb).encode()).hexdigest()
        if pcb_hash == self.kc_hash:
            logger.info(f"Hash match!")
            logger.debug(f"Clearing Diff")
            self.diff = {}
        else:
            logger.error(f"Hash mismatch!\n{pcb_hash} should be {self.kc_hash}")
            logger.debug(f"Clearing datamodel")

    # noinspection PyUnusedLocal
    def onConnectionHandlerFinished(self):
        """
        12: step: Remove datamodel from plugin instance when disconnecting:
        this way reconnection after disconnection is threated the same as connection for the first time
        (board part is redrawn)
        """
        # Clear datamodel. This causes pcb to be redrawn
        self.pcb = {}
        # Change button visibility
        self.disconnectedButtons()

    # ------------------------------------| API methods |--------------------------------------------- #
    # Method that start classes with FreeCAD API functionality in new threads.

    def startPartDrawer(self):
        """ Stars Drawer in another thread to avoid crashing FreeCAD."""
        self.pcb_drawer_thread = QtCore.QThread()
        self.pcb_drawer = FcPartDrawer(doc=self.doc,
                                       doc_gui=self.doc_gui,
                                       pcb=self.pcb,
                                       models_path=self.config.models_path)
        self.pcb_drawer.moveToThread(self.pcb_drawer_thread)
        # Connect signals
        self.pcb_drawer_thread.started.connect(self.pcb_drawer.run)
        # Finished signal
        self.pcb_drawer.finished.connect(self.pcb_drawer_thread.quit)
        self.pcb_drawer.finished.connect(self.pcb_drawer.deleteLater)
        self.pcb_drawer_thread.finished.connect(self.pcb_drawer_thread.deleteLater)
        # Connect finished signal to trigger a method
        self.pcb_drawer.finished.connect(self.onPcbDrawerFinished)
        # Log signal
        self.pcb_drawer.progress.connect(self.logDrawerProgress)
        logger.info(f"Starting PartDrawer")
        # Start thread
        self.pcb_drawer_thread.start()

    @staticmethod
    def logDrawerProgress(status: str):
        """
        This function exist because when logging in pcb_drawer module FC crashed.
        Log is passed by signal and logged here.
        """
        logger.debug(f"[DRAWER] {status}")

    def startPartScanner(self):
        """ Starts Drawer in another thread to avoid crashing FreeCAD."""
        self.scanner_thread = QtCore.QThread()
        self.scanner_obj = FcPcbScanner(doc=self.doc,
                                        pcb=self.pcb,
                                        diff=self.diff)
        self.scanner_obj.moveToThread(self.scanner_thread)

        # Connecting signals
        # Connect start signal to run() method
        self.scanner_thread.started.connect(self.scanner_obj.run)
        # Finished signal
        self.scanner_obj.finished.connect(self.scanner_thread.quit)
        self.scanner_obj.finished.connect(self.scanner_obj.deleteLater)
        self.scanner_thread.finished.connect(self.scanner_thread.deleteLater)
        # Connect finished signal to trigger a method
        self.scanner_obj.finished.connect(self.onPartScannerFinished)
        # Start thread
        logger.info(f"Starting PartScanner")
        self.scanner_thread.start()

    def startPartUpdater(self, diff: dict):
        """ Starts Drawer in another thread to avoid crashing FreeCAD."""
        self.update_thread = QtCore.QThread()
        self.update_obj = FcPartUpdater(doc=self.doc,
                                        pcb=self.pcb,
                                        diff=diff)
        self.update_obj.moveToThread(self.update_thread)
        # Connecting signals
        # Connect start signal to run() method
        self.update_thread.started.connect(self.update_obj.run)
        # Finished signal
        self.update_obj.finished.connect(self.update_thread.quit)
        self.update_obj.finished.connect(self.update_obj.deleteLater)
        self.update_thread.finished.connect(self.update_thread.deleteLater)
        # Connect finished signal to trigger a method
        self.update_obj.finished.connect(self.onPartUpdaterFinished)
        logger.info(f"Starting PartUpdater")
        # Start thread
        self.update_thread.start()

    # ------------------------------------| Utils |--------------------------------------------- #

    @staticmethod
    def findBoardPartByKIID(doc: App.Document, kiid: str) -> App.Part:
        """ Go through root level objects in document to find if board object with same KIID exists. """
        board_part = None
        for object_in_document in doc.RootObjects:
            try:
                if object_in_document.KIID == kiid:
                    board_part = object_in_document
            except AttributeError:
                # .KIID attribute is not a default attribute of all objects
                pass

        return board_part

    def sendMessage(self, msg: str, msg_type: str = "!DIS"):
        """
        Message can be type (by convention) of !DIS, REQ_PCB, REQ_DIF, PCB, DIF
        :param msg: json encoded string
        :param msg_type: str
        :return:
        """
        logger.debug(f"Sending message {msg_type}_{msg}")
        # Calculate length of first message
        msg_length = len(msg)
        send_length = str(msg_length)
        # First message is type and length of second message
        first_message = f"{msg_type}_{send_length}".encode(self.config.format)
        # Pad first message
        first_message += b' ' * (self.config.header - len(first_message))
        # Send length and object
        self.socket.send(first_message)
        self.socket.send(msg.encode(self.config.format))

    def refreshDocument(self):
        """ Recompute FreeCAD Document object. """
        logger.info(f"Recomputing document")
        self.doc.recompute()

    @staticmethod
    def dumpToJsonFile(data, filename: str):
        """ Save data to file. """
        with open(directory_path + filename, "w") as f:
            json.dump(data, f, indent=4)


# ===========================================| FCMacro |=========================================== #

# Instantiate host plugin
server_plugin = FreeCadServer()
# Add the widget to the main window right area
Gui.getMainWindow().addDockWidget(QtCore.Qt.RightDockWidgetArea, server_plugin)